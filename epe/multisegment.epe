{
  "name": "multisegment",
  "id": "us3eB9nzTuifSTXzK",
  "sources": {
    "main": "/*\n  Multisegment\n \n  Divide an LED strip into multiple segments or \"zones\", each with independent\n  RGB settings and effects. Designed for easy JSON access to allow control from\n  home automation hubs and the like.\n  \n  The UI controls work as follows: Select the active segment (default 4), then\n  set the effect for that segment: the speed, size of segment, and color for that\n  segment.\n  \n  Variables that are exported serve several purposes. One is that you can watch \n  them in the Variable Watcher (see at right), and another is that they can be\n  set over WiFi using the Websockets API.\n \n  Generously contributed by zranger1 (Jon) from the Pixelblaze forums.\n    https://github.com/zranger1\n*/\n\n// Constants\n// Field indices for segment control array\nvar __state = 0   // On/off state\nvar __hue = 1     // Hue (0-1 fixed point)\nvar __sat = 2     // Saturation (0-1 fixed point)\nvar __val = 3     // Brightness (0-1 fixed point)\nvar __effect = 4  // Effect number\nvar __size = 5    // Number of pixels in segment\nvar __speed = 6   // Effect speed (for effects that support it)\n\n// Dimensions of various data arrays\nexport var __n_segments = 4    // Number of segments\nvar __dataCols = 7      // Columns in segment control array\nvar __n_effects = 12    // Number of available effects\nvar __n_locals = 3      // Max number of per-segment local variables \n\n// GLOBAL VARIABLES \n// Per-zone color/pattern control constants and data array declaration\nexport var activeSeg = 0\n\n// Vars for mild hack to isolate sliders from one another\nvar lastColor = 0\nvar lastEffect = 0\nvar lastSpeed = 0\nvar lastSize = 0\n\n/*\n  Per segment data array. There is no hardcoded limit to the number of\n  segments. To add more, define z_<n> arrays for each new segment, following the\n  naming convention used below. Then add your new arrays to segTable in the \n  Initialize() function and set the __n_segments variable to reflect the new \n  number of zones. That's it - everything else adapts automatically.\n\n  The arrays are coded one per segment to reduce the amount of data that an \n  external program has to track per segment, as well as to reduce the amount of\n  json needed to send a command to a single segment.\n*/\nexport var z_0 = array(__dataCols)\nexport var z_1 = array(__dataCols)\nexport var z_2 = array(__dataCols)\nexport var z_3 = array(__dataCols)\n\nvar segTable = array(__n_segments)\n\n/*\n  Function tables for effects. Two pointers per effect -- prerender and render. \n  The last table entry is reserved for the \"off\" effect, which cannot be\n  selected by user input\n*/\nvar segPreRender = array(__n_effects)\nvar segRender = array(__n_effects)\n\n// Current starting pixel index for each segment\nvar segStart = array (__n_segments + 1)\nsegStart[__n_segments] = 32765 // sentinel - do not change\n\n// For fast checking during render -- is the segment\n// (1) turned on, (2) of non=zero size, and \n// (3) not pushed off the end by resizing.\nvar segEnabled = array(__n_segments)\n\n// per-segment scratch variable storage, used by effects\nvar localStore = array(__n_locals * __n_segments) \n\n// UI controls. Select the active segment, then set the effect, speed, size, and\n// color for that segment.\nexport function sliderActiveSegment(v) {\n  lastSeg = activeSeg\n  activeSeg = ceil(v * (__n_segments - 1))\n}\n\nexport function sliderEffect(v) {\n  v = floor(v * (__n_effects - 1))\n  if (lastEffect != v){\n    segTable[activeSeg][__effect] = v\n    lastEffect = v\n  }\n}\n\nexport function sliderSpeed(v) {\n  // Set up so the default speed for a pattern falls in the middle of the\n  // slider range, and moving right makes things faster.\n  if (lastSpeed != v) {\n    segTable[activeSeg][__speed] = 2 * (1 - v)\n    lastSpeed = v\n  }  \n}\n\nexport function sliderSize(v) {\n// Can't directly change last segment from UI\n  if (activeSeg >= -1 + __n_segments) return\n  \n  v = floor(v * (pixelCount - 1)) \n  if (lastSize != v){\n    segTable[activeSeg][__size] = v\n    lastSize = v\n  }\n}\n\nexport function hsvPickerColor(h, s, v) {\n  if (lastColor != (h + s + v)) {\n    segTable[activeSeg][__hue] = h\n    segTable[activeSeg][__sat] = s\n    segTable[activeSeg][__val] = v  \n    lastColor = h + s + v\n  }\n}\n\n// Helper functions\nfunction SetRenderer(n, pre, rend) {\n  segPreRender[n] = pre\n  segRender[n] = rend\n} \n\nfunction GetVar(z,index) {\n  return localStore[(__n_locals * z) + index]\n}\n\nfunction SetVar(z,index,v) {\n  localStore[(__n_locals * z) + index] = v\n}\n\n/*\n  Set size of zone, in pixels. Zero is the minimum size, pixelCount the maximum. \n  If you change the size of a zone, the zones that follow it will have their\n  sizes adjusted as well. By definition, the first zone always starts at the\n  first pixel, and the last zone ends at the last pixel.\n*/\nfunction SetSegSize(z, nPixels) {\n  var usedPixels = 0\n  \n  for (var i = 0; i < __n_segments; i++) {\n    var a = segTable[i]\n    if (i == z) { \n      a[__size] = nPixels\n    }\n    else {\n      a[__size] = clamp(a[__size], 0, pixelCount - usedPixels)\n    }  \n    usedPixels += a[__size]\n  }   \n}\n\n// Set hsv color of the specified zone\nfunction SetSegHSV(z, _h, _s, _v) {\n  segTable[z][__hue] = _h\n  segTable[z][__sat] = _s\n  segTable[z][__val] = _v\n}\n\n// set on/off state of specified zone\nfunction SetSegState(z, state) {\n  segTable[z][__state] = state\n}\n\n// set special effect for zone\nfunction SetSegEffect(z, effect) {\n  segTable[z][__effect] = effect\n}\n\n// set effect speed for zone \nfunction SetSegSpeed(z, speed) {\n  segTable[z][__speed] = speed\n}  \n\nfunction Initialize() { \n  // Initialize rendering function table  \n  SetRenderer(0, preDefault, renderDefault)\n  SetRenderer(1, preGlitter, renderGlitter)\n  SetRenderer(2, preRBounce, renderRBounce)\n  SetRenderer(3, preKITT, renderKITT)\n  SetRenderer(4, preBreathe, renderBreathe)\n  SetRenderer(5, preSlowColor, renderSlowColor)\n  SetRenderer(6, preSnow, renderSnow)\n  SetRenderer(7, preChaserUp, renderChaser)\n  SetRenderer(8, preChaserDn, renderChaser)  \n  SetRenderer(9, preStrobe, renderStrobe)\n  SetRenderer(10, preWipe, renderWipe)\n  SetRenderer(11, preSpringyTheater, renderSpringyTheater)\n\n   // set up table of segment status arrays \n  segTable[0] = z_0\n  segTable[1] = z_1\n  segTable[2] = z_2\n  segTable[3] = z_3\n\n  // start with all zones on, equal in size, and set to random colors.\n  //\n  // IMPORTANT NOTE: To customize your starting segment sizes and colors, you\n  // can move the setup function calls (like SetSegSize and SetSegHSV) from this\n  // loop and call them with the setup you want.\n  var i\n  for (i = 0; i < __n_segments; i++) {\n    SetSegState(i, true)     \n    SetSegEffect(i, floor(random(__n_effects)))\n    SetSegHSV(i, random(1), 1, .60)\n    SetSegSpeed(i, random(1))\n    SetSegSize(i, floor(pixelCount / __n_segments))\n   }\n// TBD - add custom calls to zone setup functions here!\n\n} \n\n// Given a pixel index, return the number of the segment it is in (this is the\n// slow way -- if you're short on memory and/or have a large number of pixels,\n// use this instead of indexing through segMap).\nfunction GetSegNumber(pix) { \n  for (var i = __n_segments - 1; i >= 0; i--) {\n    if (pix > segStart[i]) return i\n  }  \n  return 0  \n}\n\n// EFFECTS FUNCTIONS \n/*\n  parameters for preXXX(z, a, delta) functions are:\n    z = seg index, \n    a = ptr to segment data array, \n    delta = ms since last frame parameters \n    \n  for renderXXX(z, a, index) functions are:\n    z = seg index, \n    a = ptr to segment data array,\n    index = pixel index\n  \n  Each effect can use up to 3 per segment local variables, accessed via the\n  GetVar()/SetVar() functions. \n*/\n\n// EFFECT: default -- all pixels set to current color\nfunction preDefault(z, a, delta) { }\n\nfunction renderDefault(z, a, index) {\n  hsv(a[__hue],a[__sat],a[__val])     \n}\n  \n// EFFECT - random pixel \"glitter\"\nfunction preGlitter(z, a, delta) { }\n\nfunction renderGlitter(z, a, index) {\n  if (random(1) < 0.02) {\n    hsv(a[__hue], a[__sat], a[__val])   \n  }\n  else {\n    hsv(0, 0, 0)\n  }\n}\n\n// EFFECT: rainbow bounce \nfunction preRBounce(z, a, delta) {\n  SetVar(z, 0 ,wave(time(.03 * a[__speed])))\n}\n\nfunction renderRBounce(z, a, index) {\n  var h = GetVar(z, 0) + (index - segStart[z]) / a[__size]\n  hsv(h, 1, a[__val]) \n}\n\n// EFFECT: minimalist KITT scanner\nfunction preKITT(z, a, delta) {\n  SetVar(z, 0, max(3,a[__size] / 5)) \n  SetVar(z, 1, triangle(time(.03 * a[__speed])) * a[__size])\n  \n  g1 = GetVar(z, 0)\n  g2 = GetVar(z, 1)\n}\n\nfunction renderKITT(z, a, index) {\n  var val\n  val = 1 - clamp(abs((index - segStart[z]) - GetVar(z,1)) / GetVar(z,0), 0, 1)\n  val = val * val * a[__val]\n  hsv(a[__hue], a[__sat], val)\n}\n\n// EFFECT: pulse/flash\nfunction preBreathe(z, a, delta) {\n  SetVar(z, 0, max(0.05,wave(time(.05 * a[__speed]))))\n}\n\nfunction renderBreathe(z, a, index) {\n  hsv(a[__hue], a[__sat], GetVar(z, 0))\n}\n\n// EFFECT: slow color change\nfunction preSlowColor(z, a, delta) {\n  SetVar(z, 0, time(.2 * a[__speed]))\n}\n\nfunction renderSlowColor(z, a, index) {\n  hsv(GetVar(z, 0), a[__sat], a[__val])  \n}\n\n// EFFECT: light sparkling on snow!\nfunction preSnow(z, a, delta) {\n  var delay = delta + GetVar(z, 0)\n\n  if (GetVar(z, 1) < 0) {\n    if (delay > GetVar(z, 2)) {\n       delay = 0\n       SetVar(z, 1, segStart[z] + floor(random(1) * a[__size])) \n       SetVar(z, 2, random(750 * a[__speed])) \n    }\n  }\n  else if (delay > 80) {\n    SetVar(z, 1, -1) \n    delay = 0\n  }\n\n  SetVar(z, 0, delay)\n}\n\nfunction renderSnow(z, a, index) {\n  if (index == GetVar(z,1)) { rgb(1, 1, 1) }\n  else { hsv(a[__hue], a[__sat], a[__val]) }\n}\n\n// EFFECT: chaser up/down \nfunction preChaserUp(z, a, delta) {\n  SetVar(z, 0, time(.22 * a[__speed]))\n}\n\nfunction preChaserDn(z, a, delta) {\n  SetVar(z, 0, 1 - time(.22 * a[__speed]))\n}\n\nfunction renderChaser(z, a, index) {\n   var val = sin(GetVar(z, 0) * a[__size] + (index - segStart[z])) \n   hsv(a[__hue], a[__sat], val) \n}\n\n// EFFECT: strobe\nfunction preStrobe(z, a, delta) {\n  SetVar(z, 0, square(time(.003 * a[__speed]), .75))  \n}\n\nfunction renderStrobe(z, a, index) {\n   hsv(a[__hue], a[__sat], a[__val] * (1 - GetVar(z, 0)))   \n}\n\n// EFFECT: random color wipe\nfunction preWipe(z, a, delta) {\n  var index2 = floor(time(0.015 * a[__speed]) * a[__size])\n\n  if (index2 < GetVar(z, 0)) {\n    SetVar(z, 1, GetVar(z, 2))\n    SetVar(z, 2, time(.05))\n  }\n  SetVar(z, 0, index2)\n}\n\nfunction renderWipe(z, a, index) {\n  var h = ((index - segStart[z]) <= GetVar(z, 0)) ? GetVar(z, 2) : GetVar(z, 1)\n  hsv(h, 1, a[__val])\n}\n\nfunction preSpringyTheater(z, a, delta) {\n  SetVar(z, 0, floor(time(0.3 * a[__speed]) * a[__size]))\n  SetVar(z, 1, max(2, floor(triangle(time(0.1 * a[__speed])) * 10)))\n}\n\nfunction renderSpringyTheater(z, a, index) {\n  var val = ((GetVar(z, 0) + (index - segStart[z])) % GetVar(z, 1)) == 0\n  hsv(a[__hue], a[__sat], val)\n}\n\n\n// Evaluate current segment layout and call prerender functions for active\n// effects\nvar segNumber = 0\nexport function beforeRender(delta) {\n  var start = 0  \n\n  for (var i = 0; i < __n_segments; i++) {\n    var a = segTable[i]   \n    segStart[i] = start\n    start += a[__size]   \n    segEnabled[i] = a[__state] && \n      (segStart[i] < pixelCount) && (a[__size] > 0)\n\n    if (segEnabled[i]) segPreRender[a[__effect]](i, a, delta)\n  }\n  segNumber = 0\n}\n\n// If segment is on, call rendering fn from table. If off, set pixel off.\n// Segments of zero length are treated as \"off\".\nexport function render(index) {\n  if (index >= segStart[segNumber+1]) segNumber++\n\n    if (segEnabled[segNumber]) {\n      segRender[segTable[segNumber][__effect]](segNumber,\n        segTable[segNumber], index)\n    }\n    else {\n      hsv(0, 0, 0)\n    }\n}\n\n// Main entry point\nInitialize()\n"
  },
  "preview": "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"
}