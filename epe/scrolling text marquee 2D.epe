{
  "name": "scrolling text marquee 2D",
  "id": "zsKxPZHLmNkpjqWvL",
  "sources": {
    "main": "/*\n  Scrolling text marquee 2D\n  \n  This pattern animates ASCII characters scrolling across an LED matrix.\n  \n    Demo: https://youtu.be/668eQjiqSRQ\n  \n  The default settings work well with the $14 8x8 matrix sold here:\n  \n    https://www.tindie.com/products/electromage/electromage-8x8-led-matrix/\n  \n  Use the mapper to define how the matrix is wired (for example, zig-zag). \n  The 8x8 grid above works with the default \"Matrix\" example on the Mapper tab.\n  \n  With no map and just a 1D strip, you can use this to light paint text:\n  \n    https://photos.app.goo.gl/vU2BQsP6V84Zr6Df7\n  \n  Author: Jeff Vyduna (https://ngnr.org)\n  Bugfixes: Zeb (https://forum.electromage.com/u/zeb)\n*/\n\n// Characters we want to scroll by every second. Try 3 for a matrix, or 30 for\n// persistence-of-vision on a strip.\nvar speed = 3\n\n// Define the message to be scrolled across the display\nvar messageLength = 12\nexport var message = array(messageLength) // Exported for setting via webSockets\n\n// \"  Hello?!?\"\nmessage[0] = 32; message[1] = 32;  // Leading spaces\nmessage[2] = 72;   // H\nmessage[3] = 101;  // e\nmessage[4] = 108;  // l \nmessage[5] = 108;  // l \nmessage[6] = 111;  // o \nmessage[7] = 30; message[8] = 33; message[9] = 31 // \"?!?\"\n\n/* \n  ASCII Chart\n\n  32      48 0    65 A   74 J    83 S    97  a    106 j    115 s\n  33 !    49 1    66 B   75 K    84 T    98  b    107 k    116 t\n  34 \"    50 2    67 C   76 L    85 U    99  c    108 l    117 u\n  35 #    51 3    68 D   77 M    86 V    100 d    109 m    118 v\n  36 $    52 4    69 E   78 N    87 W    101 e    110 n    119 w\n  37 %    53 5    70 F   79 O    88 X    102 f    111 o    120 x\n  38 &    54 6    71 G   80 P    89 Y    103 g    112 p    121 y\n  39 '    55 7    72 H   81 Q    90 Z    104 h    113 q    122 z\n  40 (    56 8    73 I   82 R            105 i    114 r    \n  41 )    57 9                                   \n  42 *    58 :                   91 [                      123 {\n  43 +    59 ;                   92 \\                      124 |\n  44 ,    60 <                   93 ]                      125 }\n  45 -    61 =                   94 ^                      126 ~\n  46 .    62 >                   95 _    \n  47 /    63 ?                   96 `                \n          64 @                                            \n*/\n\n\n// Define the font's character set bitmap. See \"Font Implementation\" below.\nvar charRows = 8 // Rows in a character. 1 array per row.\nvar charCols = 8 // Columns in a character. 1 bit per column.\n\nvar fontCharCount = 128 // Max characters in the font. Must be a multiple of 4.\nvar fontBitmap = array(charRows)\nfor (row = 0; row < charRows; row++) fontBitmap[row] = array(fontCharCount / 4)\n\n// Global 8x8bit array for storing and fetching characters from fontBitmap\nvar character = array(charRows)\n\n// Define the 2D matrix display. If your matrix is different dimentions, change\n// these to match or use a smaller matrixRows to scale your text height to fill.\nvar matrixRows = 8\nvar matrixCols = 8\nvar renderBuffer = array(matrixRows)\nfor (row = 0; row < matrixRows; row++) renderBuffer[row] = array(matrixCols)\n\nvar timer = 0 // Accumulates the ms between each beforeRender()\n\n// Calculate the ms between each left shift of the message across matrix columns\nvar colShiftPeriod = 1000 / speed / charCols\n\nexport function beforeRender(delta) {\n  timer += delta\n  if (timer > colShiftPeriod) { \n    timer -= colShiftPeriod\n    loadNextCol() // Shift and load a new column every colShiftPeriod ms\n  }\n}\n\nexport var hue, sat     // Exported so you can set them over websockets\nhue = 0.05; sat = 0.9   // warm white\n\nexport function render2D(index, x, y) {\n  // y is in world units of 0...1 where (0,0) is the top-left and y is +↓\n  row = floor(y * matrixRows)\n\n  // The column to render is like the row, but physical column 0 (the leftmost)\n  // starts bufferPointer columns into the renderBuffer.\n  col = (floor(x * matrixCols) + bufferPointer) % matrixCols\n  \n  v = renderBuffer[row][col]  // 1 or 0\n  hsv(hue, sat, v)\n}\n\n// On a strip, render the leftmost column. You can use this to light paint in\n// long exposure photographs, or render text in POV projects\nexport function render(index) {\n  // Flip such that pixel 0, usually the closest to power, is the bottom of text\n  index = pixelCount - index - 1\n  \n  // Mode 1: Use entire strip as a full character line height.\n  // row = floor(charRows * index/ pixelCount)\n  \n  // Mode 2: repeat the characters vertically, with linespacing\n  // If you flicker your eyes left-right, you can see the characters.\n  // Looks best if you set `speed` above to much faster, like 30 chars/sec\n  row = index % floor(1.5 * charRows) // 0.5em lineSpacing\n  if (row > charRows - 1) { hsv(0, 0, 0); return } // blank rows\n\n  // Render column 0, which starts bufferPointer columns into the renderBuffer\n  col = bufferPointer % matrixCols\n  \n  // The color is added for light painting rainbows, and so that it's still\n  // somewhat interesting on strips / the default sequencer\n  hue = wave(time(0.02)) - index / pixelCount\n  \n  hsv(hue, sat, renderBuffer[row][col])\n}\n\n\n// When we render the renderBuffer, we start by loading the leftmost column of\n// the matrix from the `bufferPointer` column in the renderBuffer.\nvar bufferPointer = 0 \n\n/*\n  E.g.: 8x8 matrix, rendering halfway through \"AC\": Right side of A, left of C\n\n          renderbuffer[r][c]             Renders as:\n\n  `bufferPointer` == 4 means leftmost column is here, and wraps around to 3\n                     ↓       \n       col = 0 1 2 3 4 5 6 7                0 1 2 3 4 5 6 7\n    row = 0  . . . 1 1 . . .             0  1 . . . . . . 1  \n          1  . . 1 1 1 1 . .             1  1 1 . . . . 1 1  \n          2  . 1 1 . . 1 1 .             2  . 1 1 . . 1 1 .  \n          3  . 1 1 . . 1 1 .             3  . 1 1 . . 1 1 .  \n          4  . 1 1 . 1 1 1 .             4  1 1 1 . . 1 1 .  \n          4  . . 1 1 . 1 1 .             4  . 1 1 . . . 1 1  \n          5  . . . 1 . 1 1 .             5  . 1 1 . . . . 1  \n          7  . . . . . . . .             7  . . . . . . . .  \n                     ↑\n                     This column will be replaced with the next column of \"C\",\n                       ↑ then we'll advance `bufferPointer`\n                     \nEach element is a 16.16 fixed point number, so you could decide to pack HSV or \nRGB info into each byte, but this example is monochrome so each element just \nstores a 0 or 1, making rendering as simple as:\n\n    if (renderBuffer[row][col]) hsv(0,0,1)\n*/\n\nvar messageCols = messageLength * charCols // e.g., 12 chars have 96 columns\nvar messageColPointer = 0 // The next column of the overall message to load\n\n// Load the next column from `message` into `renderBuffer` at `bufferPointer`\nfunction loadNextCol() {\n  charIndex = message[floor(messageColPointer / charCols)]\n  fetchCharacter(charIndex) // loads global `character` with ASCII charIndex\n  \n  colIndex = messageColPointer % charCols\n  for (row = 0; row < charRows; row++) {\n    bit = (((character[row] << colIndex) & 0b10000000) == 0b10000000)\n    renderBuffer[row][bufferPointer] = bit\n  }\n  \n  bufferPointer = (bufferPointer + 1) % matrixCols\n  messageColPointer = (messageColPointer + 1) % messageCols\n}\n\n\n\n/*\n  Font Implementation\n  \n  Pixelblaze currently supports up to 64 arrays with 2048 array elements.\n  \n  To store a character set of 8x8 bit characters, we use 8 arrays, \n  one for each row.\n  \n  Four 8-bit maps are packed into each 32 bit array element. This makes the\n  bitwise code a little hard to follow, but uses memory efficiently. The 8 most\n  significant bits are referred to as \"bank 0\"; the next eight bits just left of\n  the binary point are \"bank 1\", etc.\n  \n  Here's the scheme used to store the font bitmap. A period is a zero.\n  \n    ASCII character  A        B        C        D        E\n        `charIndex`  65       66       67       68       69\n      array element  [16]     [16]     [16]     [16]     [17]\n               bank  0        1        2        3        0      \n      fontBitmap[0]  ..11.... 111111.. ..1111.. 11111... 1111111.\n      fontBitmap[1]  .1111... .11..11. .11..11. .11.11.. .11...1.\n      fontBitmap[2]  11..11.. .11..11. 11...... .11..11. .11.1...\n      fontBitmap[3]  11..11.. .11111.. 11...... .11..11. .1111...\n      fontBitmap[4]  111111.. .11..11. 11...... .11..11. .11.1...\n      fontBitmap[5]  11..11.. .11..11. .11..11. .11.11.. .11...1.\n      fontBitmap[6]  11..11.. 111111.. ..1111.. 11111... 1111111.\n      fontBitmap[7]  ........ ........ ........ ........ ........\n  \n  charIndex 0..31 (traditionally the ASCII control characters) are left \n  blank for user-defined custom characters.\n*/\n\n/*\n  Font and character functions\n\n  The storeCharacter functions take the character index (< `fontCharCount`) and \n  8 rows of 8 bits. Each row is a byte representing 8 bits of on/off bitmap data\n  to become the pixels of a character. Therefore, this implementation is \n  currently tightly coupled to 8-bit wide characters.\n*/\n\n/*\n  At character index `charIndex`, store 8 bytes of row data specified as \n  sequential arguments r0-r7. This allows us to easily use the public domain \n  font specified as comma-delimited hex bytes at:\n  \n  https://github.com/rene-d/fontino/blob/master/font8x8_ib8x8u.ino\n*/\nfunction storeCharacter(charIndex, r0, r1, r2, r3, r4, r5, r6, r7) {\n  element = floor(charIndex / 4)\n  bank = charIndex % 4\n  packByte(0, element, bank, r0)\n  packByte(1, element, bank, r1)\n  packByte(2, element, bank, r2)\n  packByte(3, element, bank, r3)\n  packByte(4, element, bank, r4)\n  packByte(5, element, bank, r5)\n  packByte(6, element, bank, r6)\n  packByte(7, element, bank, r7)\n}\n\n/*\n  This alternate style stores the character using the 8 row global array named \n  `character`. It could be useful for storing sprites after transformations to\n  create animations.\n*/\nfunction storeCharacter2(charIndex) {\n  element = floor(charIndex / 4)\n  bank = charIndex % 4\n  for (var row = 0; row < charRows; row++) {\n    packByte(row, element, bank, character[row])\n  }\n}\n\n// Loads the global `character` from the specified charIndex\nfunction fetchCharacter(charIndex) {\n  element = floor(charIndex / 4)\n  bank = charIndex % 4\n  for (var row = 0; row < charRows; row++) {\n    character[row] = unpackByte(row, element, bank)\n  }\n}\n\n/*\n  For a given row of a font's pixel data (fontBitmap[row]), there's a \n  (fontCharCount / 4) element long array that holds 32 bits per array element. \n  Thinking of each array element as a 4-byte word, the \"bank\" (0..3) specifies \n  which set of 8 bits we're storing for a particular character. Characters are \n  referred to by their charIndex (ASCII number), so:\n  bank 0 in elements 0, 1, & 2 store the data for characters 0, 4, 8, etc;\n  Bank 1 in elements 0, 1, & 2 store the data for characters 1, 5, 9, etc.\n  \n  The method below is used because the bitwise operators only work on \n  the top 16 bits.\n*/\nvar byteHolder = array(4)\nfunction packByte(row, element, bank, byte) {\n  original = fontBitmap[row][element]\n  \n  // Load a 4-element array with the individual bytes in this 32 bit 'word'\n  for (_bank = 0; _bank < 4; _bank++) {\n    byteHolder[_bank] = (((original << (_bank * 8)) & 0xFF00) >> 8) & 0xFF\n  }\n  \n  // Override the 8 bits we're trying to store\n  byteHolder[bank] = byte \n  \n  // Reassemble the 32 bit 'word'\n  fontBitmap[row][element] = (byteHolder[0] << 8) \n                            + byteHolder[1] \n                           + (byteHolder[2] >> 8) \n                           + (byteHolder[3] >> 16)\n}\n\n// Inverse of packByte()\nfunction unpackByte(row, element, bank) {\n  word = fontBitmap[row][element]\n  if (bank > 1) {\n    byte = word << (8 * (bank - 1))\n  } else if (bank == 0) {\n    byte = word >> 8\n  } else {\n    byte = word\n  }\n  return byte & 0xFF // Zero out all but the 8 bits left of the binary point\n}\n\n\n\n/* \n  Font Data\n\n  Public domain, courtesy of\n  https://github.com/rene-d/fontino/blob/master/font8x8_ib8x8u.ino\n*/\n\nstoreCharacter( 32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)  // 0x20 (space)\nstoreCharacter( 33, 0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00)  // 0x21 (exclam)\nstoreCharacter( 34, 0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00)  // 0x22 (quotedbl)\nstoreCharacter( 35, 0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00)  // 0x23 (numbersign)\nstoreCharacter( 36, 0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00)  // 0x24 (dollar)\nstoreCharacter( 37, 0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00)  // 0x25 (percent)\nstoreCharacter( 38, 0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00)  // 0x26 (ampersand)\nstoreCharacter( 39, 0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00)  // 0x27 (quotesingle)\nstoreCharacter( 40, 0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00)  // 0x28 (parenleft)\nstoreCharacter( 41, 0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00)  // 0x29 (parenright)\nstoreCharacter( 42, 0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00)  // 0x2a (asterisk)\nstoreCharacter( 43, 0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00)  // 0x2b (plus)\nstoreCharacter( 44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60)  // 0x2c (comma)\nstoreCharacter( 45, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00)  // 0x2d (hyphen)\nstoreCharacter( 46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00)  // 0x2e (period)\nstoreCharacter( 47, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00)  // 0x2f (slash)\nstoreCharacter( 48, 0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00)  // 0x30 (zero)\nstoreCharacter( 49, 0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00)  // 0x31 (one)\nstoreCharacter( 50, 0x78, 0xcc, 0x0c, 0x38, 0x60, 0xc4, 0xfc, 0x00)  // 0x32 (two)\nstoreCharacter( 51, 0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00)  // 0x33 (three)\nstoreCharacter( 52, 0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00)  // 0x34 (four)\nstoreCharacter( 53, 0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00)  // 0x35 (five)\nstoreCharacter( 54, 0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00)  // 0x36 (six)\nstoreCharacter( 55, 0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00)  // 0x37 (seven)\nstoreCharacter( 56, 0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00)  // 0x38 (eight)\nstoreCharacter( 57, 0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00)  // 0x39 (nine)\nstoreCharacter( 58, 0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00)  // 0x3a (colon)\nstoreCharacter( 59, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x60, 0x00)  // 0x3b (semicolon)\nstoreCharacter( 60, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00)  // 0x3c (less)\nstoreCharacter( 61, 0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00)  // 0x3d (equal)\nstoreCharacter( 62, 0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00)  // 0x3e (greater)\nstoreCharacter( 63, 0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00)  // 0x3f (question)\nstoreCharacter( 64, 0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00)  // 0x40 (at)\nstoreCharacter( 65, 0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00)  // 0x41 (A)\nstoreCharacter( 66, 0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00)  // 0x42 (B)\nstoreCharacter( 67, 0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00)  // 0x43 (C)\nstoreCharacter( 68, 0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00)  // 0x44 (D)\nstoreCharacter( 69, 0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00)  // 0x45 (E)\nstoreCharacter( 70, 0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00)  // 0x46 (F)\nstoreCharacter( 71, 0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00)  // 0x47 (G)\nstoreCharacter( 72, 0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00)  // 0x48 (H)\nstoreCharacter( 73, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00)  // 0x49 (I)\nstoreCharacter( 74, 0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00)  // 0x4a (J)\nstoreCharacter( 75, 0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00)  // 0x4b (K)\nstoreCharacter( 76, 0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00)  // 0x4c (L)\nstoreCharacter( 77, 0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00)  // 0x4d (M)\nstoreCharacter( 78, 0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00)  // 0x4e (N)\nstoreCharacter( 79, 0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00)  // 0x4f (O)\nstoreCharacter( 80, 0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00)  // 0x50 (P)\nstoreCharacter( 81, 0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00)  // 0x51 (Q)\nstoreCharacter( 82, 0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00)  // 0x52 (R)\nstoreCharacter( 83, 0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00)  // 0x53 (S)\nstoreCharacter( 84, 0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00)  // 0x54 (T)\nstoreCharacter( 85, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00)  // 0x55 (U)\nstoreCharacter( 86, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00)  // 0x56 (V)\nstoreCharacter( 87, 0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00)  // 0x57 (W)\nstoreCharacter( 88, 0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00)  // 0x58 (X)\nstoreCharacter( 89, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00)  // 0x59 (Y)\nstoreCharacter( 90, 0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00)  // 0x5a (Z)\nstoreCharacter( 91, 0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00)  // 0x5b (bracketleft)\nstoreCharacter( 92, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00)  // 0x5c (backslash)\nstoreCharacter( 93, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00)  // 0x5d (bracketright)\nstoreCharacter( 94, 0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00)  // 0x5e (asciicircum)\nstoreCharacter( 95, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff)  // 0x5f (underscore)\nstoreCharacter( 96, 0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00)  // 0x60 (grave)\nstoreCharacter( 97, 0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00)  // 0x61 (a)\nstoreCharacter( 98, 0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00)  // 0x62 (b)\nstoreCharacter( 99, 0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00)  // 0x63 (c)\nstoreCharacter(100, 0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00)  // 0x64 (d)\nstoreCharacter(101, 0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00)  // 0x65 (e)\nstoreCharacter(102, 0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00)  // 0x66 (f)\nstoreCharacter(103, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8)  // 0x67 (g)\nstoreCharacter(104, 0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00)  // 0x68 (h)\nstoreCharacter(105, 0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00)  // 0x69 (i)\nstoreCharacter(106, 0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78)  // 0x6a (j)\nstoreCharacter(107, 0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00)  // 0x6b (k)\nstoreCharacter(108, 0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00)  // 0x6c (l)\nstoreCharacter(109, 0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00)  // 0x6d (m)\nstoreCharacter(110, 0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00)  // 0x6e (n)\nstoreCharacter(111, 0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00)  // 0x6f (o)\nstoreCharacter(112, 0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0)  // 0x70 (p)\nstoreCharacter(113, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e)  // 0x71 (q)\nstoreCharacter(114, 0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00)  // 0x72 (r)\nstoreCharacter(115, 0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00)  // 0x73 (s)\nstoreCharacter(116, 0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00)  // 0x74 (t)\nstoreCharacter(117, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00)  // 0x75 (u)\nstoreCharacter(118, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00)  // 0x76 (v)\nstoreCharacter(119, 0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00)  // 0x77 (w)\nstoreCharacter(120, 0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00)  // 0x78 (x)\nstoreCharacter(121, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8)  // 0x79 (y)\nstoreCharacter(122, 0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00)  // 0x7a (z)\nstoreCharacter(123, 0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00)  // 0x7b (braceleft)\nstoreCharacter(124, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00)  // 0x7c (bar)\nstoreCharacter(125, 0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00)  // 0x7d (braceright)\nstoreCharacter(126, 0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)  // 0x7e (asciitilde)\n\n\n// Other user-defined custom characters\n\n// ASCII 63 is the question mark - here's an alternative from the \n// Sinclair ZX81 font, stored in custom slot 30\nstoreCharacter(30,\n  0b00000000,\n  0b00111100,\n  0b01000010,\n  0b00000100,\n  0b00001000,\n  0b00000000,\n  0b00001000,\n  0b00000000\n)\n\n// This demonstrates copying the character, altering it, then storing it in the \n// next slot. You could use this for programmatic animation.\nfetchCharacter(30)\ncharacter[7] = 0b00001000\nstoreCharacter2(31)\n"
  },
  "preview": "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"
}