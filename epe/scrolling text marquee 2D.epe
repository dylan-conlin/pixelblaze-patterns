{
  "name": "scrolling text marquee 2D",
  "id": "zsKxPZHLmNkpjqWvL",
  "sources": {
    "main": "/*\n  Scrolling text marquee 2D\n  \n  This pattern animates ASCII characters scrolling across an LED matrix.\n  \n    Demo: https://youtu.be/668eQjiqSRQ\n  \n  The default settings work well with the $14 8x8 matrix sold here:\n  \n    https://www.tindie.com/products/electromage/electromage-8x8-led-matrix/\n  \n  Use the mapper to define how the matrix is wired (for example, zig-zag). \n  The 8x8 grid above works with the default \"Matrix\" example on the Mapper tab.\n  \n  With no map and just a 1D strip, you can use this to light paint text:\n  \n    https://photos.app.goo.gl/vU2BQsP6V84Zr6Df7\n  \n  Author: Jeff Vyduna (https://ngnr.org)\n  Bugfixes: Zeb (https://forum.electromage.com/u/zeb)\n*/\n\n// Characters we want to scroll by every second. Try 3 for a matrix, or 30 for\n// persistence-of-vision on a strip.\nvar speed = 3\n\n// Define the message to be scrolled across the display\nvar messageLength = 12\nexport var message = array(messageLength) // Exported for setting via webSockets\n\n// \"  Hello?!?\"\nmessage[0] = 32; message[1] = 32;  // Leading spaces\nmessage[2] = 72;   // H\nmessage[3] = 101;  // e\nmessage[4] = 108;  // l \nmessage[5] = 108;  // l \nmessage[6] = 111;  // o \nmessage[7] = 30; message[8] = 33; message[9] = 31 // \"?!?\"\n\n/* \n  ASCII Chart\n\n  32      48 0    65 A   74 J    83 S    97  a    106 j    115 s\n  33 !    49 1    66 B   75 K    84 T    98  b    107 k    116 t\n  34 \"    50 2    67 C   76 L    85 U    99  c    108 l    117 u\n  35 #    51 3    68 D   77 M    86 V    100 d    109 m    118 v\n  36 $    52 4    69 E   78 N    87 W    101 e    110 n    119 w\n  37 %    53 5    70 F   79 O    88 X    102 f    111 o    120 x\n  38 &    54 6    71 G   80 P    89 Y    103 g    112 p    121 y\n  39 '    55 7    72 H   81 Q    90 Z    104 h    113 q    122 z\n  40 (    56 8    73 I   82 R            105 i    114 r    \n  41 )    57 9                                   \n  42 *    58 :                   91 [                      123 {\n  43 +    59 ;                   92 \\                      124 |\n  44 ,    60 <                   93 ]                      125 }\n  45 -    61 =                   94 ^                      126 ~\n  46 .    62 >                   95 _    \n  47 /    63 ?                   96 `                \n          64 @                                            \n*/\n\n\n// Define the font's character set bitmap. See \"Font Implementation\" below.\nvar charRows = 8 // Rows in a character. 1 array per row.\nvar charCols = 8 // Columns in a character. 1 bit per column.\n\nvar fontCharCount = 128 // Max characters in the font. Must be a multiple of 4.\nvar fontBitmap = array(charRows)\nfor (row = 0; row < charRows; row++) fontBitmap[row] = array(fontCharCount / 4)\n\n// Global 8x8bit array for storing and fetching characters from fontBitmap\nvar character = array(charRows)\n\n// Define the 2D matrix display. If your matrix is different dimentions, change\n// these to match or use a smaller matrixRows to scale your text height to fill.\nvar matrixRows = 8\nvar matrixCols = 8\nvar renderBuffer = array(matrixRows)\nfor (row = 0; row < matrixRows; row++) renderBuffer[row] = array(matrixCols)\n\nvar timer = 0 // Accumulates the ms between each beforeRender()\n\n// Calculate the ms between each left shift of the message across matrix columns\nvar colShiftPeriod = 1000 / speed / charCols\n\nexport function beforeRender(delta) {\n  timer += delta\n  if (timer > colShiftPeriod) { \n    timer -= colShiftPeriod\n    loadNextCol() // Shift and load a new column every colShiftPeriod ms\n  }\n}\n\nexport var hue, sat     // Exported so you can set them over websockets\nhue = 0.05; sat = 0.9   // warm white\n\nexport function render2D(index, x, y) {\n  // y is in world units of 0...1 where (0,0) is the top-left and y is +↓\n  row = floor(y * matrixRows)\n\n  // The column to render is like the row, but physical column 0 (the leftmost)\n  // starts bufferPointer columns into the renderBuffer.\n  col = (floor(x * matrixCols) + bufferPointer) % matrixCols\n  \n  v = renderBuffer[row][col]  // 1 or 0\n  hsv(hue, sat, v)\n}\n\n// On a strip, render the leftmost column. You can use this to light paint in\n// long exposure photographs, or render text in POV projects\nexport function render(index) {\n  // Flip such that pixel 0, usually the closest to power, is the bottom of text\n  index = pixelCount - index - 1\n  \n  // Mode 1: Use entire strip as a full character line height.\n  // row = floor(charRows * index/ pixelCount)\n  \n  // Mode 2: repeat the characters vertically, with linespacing\n  // If you flicker your eyes left-right, you can see the characters.\n  // Looks best if you set `speed` above to much faster, like 30 chars/sec\n  row = index % floor(1.5 * charRows) // 0.5em lineSpacing\n  if (row > charRows - 1) { hsv(0, 0, 0); return } // blank rows\n\n  // Render column 0, which starts bufferPointer columns into the renderBuffer\n  col = bufferPointer % matrixCols\n  \n  // The color is added for light painting rainbows, and so that it's still\n  // somewhat interesting on strips / the default sequencer\n  hue = wave(time(0.02)) - index / pixelCount\n  \n  hsv(hue, sat, renderBuffer[row][col])\n}\n\n\n// When we render the renderBuffer, we start by loading the leftmost column of\n// the matrix from the `bufferPointer` column in the renderBuffer.\nvar bufferPointer = 0 \n\n/*\n  E.g.: 8x8 matrix, rendering halfway through \"AC\": Right side of A, left of C\n\n          renderbuffer[r][c]             Renders as:\n\n  `bufferPointer` == 4 means leftmost column is here, and wraps around to 3\n                     ↓       \n       col = 0 1 2 3 4 5 6 7                0 1 2 3 4 5 6 7\n    row = 0  . . . 1 1 . . .             0  1 . . . . . . 1  \n          1  . . 1 1 1 1 . .             1  1 1 . . . . 1 1  \n          2  . 1 1 . . 1 1 .             2  . 1 1 . . 1 1 .  \n          3  . 1 1 . . 1 1 .             3  . 1 1 . . 1 1 .  \n          4  . 1 1 . 1 1 1 .             4  1 1 1 . . 1 1 .  \n          4  . . 1 1 . 1 1 .             4  . 1 1 . . . 1 1  \n          5  . . . 1 . 1 1 .             5  . 1 1 . . . . 1  \n          7  . . . . . . . .             7  . . . . . . . .  \n                     ↑\n                     This column will be replaced with the next column of \"C\",\n                       ↑ then we'll advance `bufferPointer`\n                     \nEach element is a 16.16 fixed point number, so you could decide to pack HSV or \nRGB info into each byte, but this example is monochrome so each element just \nstores a 0 or 1, making rendering as simple as:\n\n    if (renderBuffer[row][col]) hsv(0,0,1)\n*/\n\nvar messageCols = messageLength * charCols // e.g., 12 chars have 96 columns\nvar messageColPointer = 0 // The next column of the overall message to load\n\n// Load the next column from `message` into `renderBuffer` at `bufferPointer`\nfunction loadNextCol() {\n  charIndex = message[floor(messageColPointer / charCols)]\n  fetchCharacter(charIndex) // loads global `character` with ASCII charIndex\n  \n  colIndex = messageColPointer % charCols\n  for (row = 0; row < charRows; row++) {\n    bit = (((character[row] << colIndex) & 0b10000000) == 0b10000000)\n    renderBuffer[row][bufferPointer] = bit\n  }\n  \n  bufferPointer = (bufferPointer + 1) % matrixCols\n  messageColPointer = (messageColPointer + 1) % messageCols\n}\n\n\n\n/*\n  Font Implementation\n  \n  Pixelblaze currently supports up to 64 arrays with 2048 array elements.\n  \n  To store a character set of 8x8 bit characters, we use 8 arrays, \n  one for each row.\n  \n  Four 8-bit maps are packed into each 32 bit array element. This makes the\n  bitwise code a little hard to follow, but uses memory efficiently. The 8 most\n  significant bits are referred to as \"bank 0\"; the next eight bits just left of\n  the binary point are \"bank 1\", etc.\n  \n  Here's the scheme used to store the font bitmap. A period is a zero.\n  \n    ASCII character  A        B        C        D        E\n        `charIndex`  65       66       67       68       69\n      array element  [16]     [16]     [16]     [16]     [17]\n               bank  0        1        2        3        0      \n      fontBitmap[0]  ..11.... 111111.. ..1111.. 11111... 1111111.\n      fontBitmap[1]  .1111... .11..11. .11..11. .11.11.. .11...1.\n      fontBitmap[2]  11..11.. .11..11. 11...... .11..11. .11.1...\n      fontBitmap[3]  11..11.. .11111.. 11...... .11..11. .1111...\n      fontBitmap[4]  111111.. .11..11. 11...... .11..11. .11.1...\n      fontBitmap[5]  11..11.. .11..11. .11..11. .11.11.. .11...1.\n      fontBitmap[6]  11..11.. 111111.. ..1111.. 11111... 1111111.\n      fontBitmap[7]  ........ ........ ........ ........ ........\n  \n  charIndex 0..31 (traditionally the ASCII control characters) are left \n  blank for user-defined custom characters.\n*/\n\n/*\n  Font and character functions\n\n  The storeCharacter functions take the character index (< `fontCharCount`) and \n  8 rows of 8 bits. Each row is a byte representing 8 bits of on/off bitmap data\n  to become the pixels of a character. Therefore, this implementation is \n  currently tightly coupled to 8-bit wide characters.\n*/\n\n/*\n  At character index `charIndex`, store 8 bytes of row data specified as \n  sequential arguments r0-r7. This allows us to easily use the public domain \n  font specified as comma-delimited hex bytes at:\n  \n  https://github.com/rene-d/fontino/blob/master/font8x8_ib8x8u.ino\n*/\nfunction storeCharacter(charIndex, r0, r1, r2, r3, r4, r5, r6, r7) {\n  element = floor(charIndex / 4)\n  bank = charIndex % 4\n  packByte(0, element, bank, r0)\n  packByte(1, element, bank, r1)\n  packByte(2, element, bank, r2)\n  packByte(3, element, bank, r3)\n  packByte(4, element, bank, r4)\n  packByte(5, element, bank, r5)\n  packByte(6, element, bank, r6)\n  packByte(7, element, bank, r7)\n}\n\n/*\n  This alternate style stores the character using the 8 row global array named \n  `character`. It could be useful for storing sprites after transformations to\n  create animations.\n*/\nfunction storeCharacter2(charIndex) {\n  element = floor(charIndex / 4)\n  bank = charIndex % 4\n  for (var row = 0; row < charRows; row++) {\n    packByte(row, element, bank, character[row])\n  }\n}\n\n// Loads the global `character` from the specified charIndex\nfunction fetchCharacter(charIndex) {\n  element = floor(charIndex / 4)\n  bank = charIndex % 4\n  for (var row = 0; row < charRows; row++) {\n    character[row] = unpackByte(row, element, bank)\n  }\n}\n\n/*\n  For a given row of a font's pixel data (fontBitmap[row]), there's a \n  (fontCharCount / 4) element long array that holds 32 bits per array element. \n  Thinking of each array element as a 4-byte word, the \"bank\" (0..3) specifies \n  which set of 8 bits we're storing for a particular character. Characters are \n  referred to by their charIndex (ASCII number), so:\n  bank 0 in elements 0, 1, & 2 store the data for characters 0, 4, 8, etc;\n  Bank 1 in elements 0, 1, & 2 store the data for characters 1, 5, 9, etc.\n  \n  The method below is used because the bitwise operators only work on \n  the top 16 bits.\n*/\nvar byteHolder = array(4)\nfunction packByte(row, element, bank, byte) {\n  original = fontBitmap[row][element]\n  \n  // Load a 4-element array with the individual bytes in this 32 bit 'word'\n  for (_bank = 0; _bank < 4; _bank++) {\n    byteHolder[_bank] = (((original << (_bank * 8)) & 0xFF00) >> 8) & 0xFF\n  }\n  \n  // Override the 8 bits we're trying to store\n  byteHolder[bank] = byte \n  \n  // Reassemble the 32 bit 'word'\n  fontBitmap[row][element] = (byteHolder[0] << 8) \n                            + byteHolder[1] \n                           + (byteHolder[2] >> 8) \n                           + (byteHolder[3] >> 16)\n}\n\n// Inverse of packByte()\nfunction unpackByte(row, element, bank) {\n  word = fontBitmap[row][element]\n  if (bank > 1) {\n    byte = word << (8 * (bank - 1))\n  } else if (bank == 0) {\n    byte = word >> 8\n  } else {\n    byte = word\n  }\n  return byte & 0xFF // Zero out all but the 8 bits left of the binary point\n}\n\n\n\n/* \n  Font Data\n\n  Public domain, courtesy of\n  https://github.com/rene-d/fontino/blob/master/font8x8_ib8x8u.ino\n*/\n\nstoreCharacter( 32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)  // 0x20 (space)\nstoreCharacter( 33, 0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00)  // 0x21 (exclam)\nstoreCharacter( 34, 0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00)  // 0x22 (quotedbl)\nstoreCharacter( 35, 0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00)  // 0x23 (numbersign)\nstoreCharacter( 36, 0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00)  // 0x24 (dollar)\nstoreCharacter( 37, 0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00)  // 0x25 (percent)\nstoreCharacter( 38, 0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00)  // 0x26 (ampersand)\nstoreCharacter( 39, 0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00)  // 0x27 (quotesingle)\nstoreCharacter( 40, 0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00)  // 0x28 (parenleft)\nstoreCharacter( 41, 0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00)  // 0x29 (parenright)\nstoreCharacter( 42, 0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00)  // 0x2a (asterisk)\nstoreCharacter( 43, 0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00)  // 0x2b (plus)\nstoreCharacter( 44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60)  // 0x2c (comma)\nstoreCharacter( 45, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00)  // 0x2d (hyphen)\nstoreCharacter( 46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00)  // 0x2e (period)\nstoreCharacter( 47, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00)  // 0x2f (slash)\nstoreCharacter( 48, 0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00)  // 0x30 (zero)\nstoreCharacter( 49, 0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00)  // 0x31 (one)\nstoreCharacter( 50, 0x78, 0xcc, 0x0c, 0x38, 0x60, 0xc4, 0xfc, 0x00)  // 0x32 (two)\nstoreCharacter( 51, 0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00)  // 0x33 (three)\nstoreCharacter( 52, 0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00)  // 0x34 (four)\nstoreCharacter( 53, 0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00)  // 0x35 (five)\nstoreCharacter( 54, 0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00)  // 0x36 (six)\nstoreCharacter( 55, 0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00)  // 0x37 (seven)\nstoreCharacter( 56, 0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00)  // 0x38 (eight)\nstoreCharacter( 57, 0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00)  // 0x39 (nine)\nstoreCharacter( 58, 0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00)  // 0x3a (colon)\nstoreCharacter( 59, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x60, 0x00)  // 0x3b (semicolon)\nstoreCharacter( 60, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00)  // 0x3c (less)\nstoreCharacter( 61, 0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00)  // 0x3d (equal)\nstoreCharacter( 62, 0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00)  // 0x3e (greater)\nstoreCharacter( 63, 0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00)  // 0x3f (question)\nstoreCharacter( 64, 0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00)  // 0x40 (at)\nstoreCharacter( 65, 0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00)  // 0x41 (A)\nstoreCharacter( 66, 0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00)  // 0x42 (B)\nstoreCharacter( 67, 0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00)  // 0x43 (C)\nstoreCharacter( 68, 0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00)  // 0x44 (D)\nstoreCharacter( 69, 0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00)  // 0x45 (E)\nstoreCharacter( 70, 0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00)  // 0x46 (F)\nstoreCharacter( 71, 0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00)  // 0x47 (G)\nstoreCharacter( 72, 0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00)  // 0x48 (H)\nstoreCharacter( 73, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00)  // 0x49 (I)\nstoreCharacter( 74, 0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00)  // 0x4a (J)\nstoreCharacter( 75, 0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00)  // 0x4b (K)\nstoreCharacter( 76, 0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00)  // 0x4c (L)\nstoreCharacter( 77, 0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00)  // 0x4d (M)\nstoreCharacter( 78, 0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00)  // 0x4e (N)\nstoreCharacter( 79, 0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00)  // 0x4f (O)\nstoreCharacter( 80, 0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00)  // 0x50 (P)\nstoreCharacter( 81, 0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00)  // 0x51 (Q)\nstoreCharacter( 82, 0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00)  // 0x52 (R)\nstoreCharacter( 83, 0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00)  // 0x53 (S)\nstoreCharacter( 84, 0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00)  // 0x54 (T)\nstoreCharacter( 85, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00)  // 0x55 (U)\nstoreCharacter( 86, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00)  // 0x56 (V)\nstoreCharacter( 87, 0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00)  // 0x57 (W)\nstoreCharacter( 88, 0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00)  // 0x58 (X)\nstoreCharacter( 89, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00)  // 0x59 (Y)\nstoreCharacter( 90, 0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00)  // 0x5a (Z)\nstoreCharacter( 91, 0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00)  // 0x5b (bracketleft)\nstoreCharacter( 92, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00)  // 0x5c (backslash)\nstoreCharacter( 93, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00)  // 0x5d (bracketright)\nstoreCharacter( 94, 0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00)  // 0x5e (asciicircum)\nstoreCharacter( 95, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff)  // 0x5f (underscore)\nstoreCharacter( 96, 0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00)  // 0x60 (grave)\nstoreCharacter( 97, 0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00)  // 0x61 (a)\nstoreCharacter( 98, 0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00)  // 0x62 (b)\nstoreCharacter( 99, 0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00)  // 0x63 (c)\nstoreCharacter(100, 0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00)  // 0x64 (d)\nstoreCharacter(101, 0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00)  // 0x65 (e)\nstoreCharacter(102, 0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00)  // 0x66 (f)\nstoreCharacter(103, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8)  // 0x67 (g)\nstoreCharacter(104, 0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00)  // 0x68 (h)\nstoreCharacter(105, 0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00)  // 0x69 (i)\nstoreCharacter(106, 0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78)  // 0x6a (j)\nstoreCharacter(107, 0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00)  // 0x6b (k)\nstoreCharacter(108, 0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00)  // 0x6c (l)\nstoreCharacter(109, 0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00)  // 0x6d (m)\nstoreCharacter(110, 0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00)  // 0x6e (n)\nstoreCharacter(111, 0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00)  // 0x6f (o)\nstoreCharacter(112, 0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0)  // 0x70 (p)\nstoreCharacter(113, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e)  // 0x71 (q)\nstoreCharacter(114, 0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00)  // 0x72 (r)\nstoreCharacter(115, 0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00)  // 0x73 (s)\nstoreCharacter(116, 0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00)  // 0x74 (t)\nstoreCharacter(117, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00)  // 0x75 (u)\nstoreCharacter(118, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00)  // 0x76 (v)\nstoreCharacter(119, 0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00)  // 0x77 (w)\nstoreCharacter(120, 0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00)  // 0x78 (x)\nstoreCharacter(121, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8)  // 0x79 (y)\nstoreCharacter(122, 0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00)  // 0x7a (z)\nstoreCharacter(123, 0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00)  // 0x7b (braceleft)\nstoreCharacter(124, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00)  // 0x7c (bar)\nstoreCharacter(125, 0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00)  // 0x7d (braceright)\nstoreCharacter(126, 0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)  // 0x7e (asciitilde)\n\n\n// Other user-defined custom characters\n\n// ASCII 63 is the question mark - here's an alternative from the \n// Sinclair ZX81 font, stored in custom slot 30\nstoreCharacter(30,\n  0b00000000,\n  0b00111100,\n  0b01000010,\n  0b00000100,\n  0b00001000,\n  0b00000000,\n  0b00001000,\n  0b00000000\n)\n\n// This demonstrates copying the character, altering it, then storing it in the \n// next slot. You could use this for programmatic animation.\nfetchCharacter(30)\ncharacter[7] = 0b00001000\nstoreCharacter2(31)"
  },
  "preview": "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"
}