{
  "name": "Geometry Morphing Demo",
  "id": "hp7RgYQDwpfQFu9Yk",
  "sources": {
    "main": "/* Geometry Morphing Demo 2D\n\n Smooth transitions between animated geometric shapes.  \n \n This pattern shows how to draw and dynamically modify geometric\n objects using a pixel shader and signed distance functions.  Since this \n method scales automatically with the number of available processors, it \n is most often used on GPU-based systems.  It's also very well suited to\n the Pixelblaze's architecture.\n \n For more information, see:\n   Basic tutorial on this style of rendering:\n     https://www.shadertoy.com/view/Xl2XWt\n   Distance functions for many 2D shapes:\n     https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n MIT License\n Take this code and use it to make cool things!\n \n Version  Author        Date      \n 1.0.0    ZRanger1 08/09/2021\n*/ \n\n// UI control variables\nexport var objectSize = 0.45;\nexport var lineWidth = 0.05;\nvar filled = 1;\n\n// shape function selection \nvar numShapes = 6;\nvar shapeSdf = array(numShapes)\nvar shapeCompare = array(2);\n\n// animation control\nvar shape = 0;\nvar nextShape = 1;\nvar hue = 0;\nvar morphClock = 0;\nvar wait = 0; \nvar lerpPct = 0;\n\nshapeCompare[0] = (f) => (abs(f) > lineWidth); // unfilled shapes\nshapeCompare[1] = (f) => (f > lineWidth);      // filled shapes\n\nshapeSdf[0] = circle;\nshapeSdf[1] = cross;\nshapeSdf[2] = hexStar;\nshapeSdf[3] = square;\nshapeSdf[4] = triangle;\nshapeSdf[5] = hexagon;\n\nfunction signum(a) {\n  return (a > 0) - (a < 0)\n}\n\n// signed distance functions for various shapes, adapted for 2D. \n// Math from https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfunction circle(x,y,r) {\n  return hypot(x,y) - r;\n}\n\nfunction square(x,y,size) {\n  dx = abs(x) - size;  d1 = max(dx,0);\n  dy = abs(y) - size;  d2 = max(dy,0);\n\treturn min(max(dx, dy), 0.0) + hypot(d1,d2);\n}\n\nfunction triangle(x,y,r) {\n\treturn max((abs(x) * 0.866025) - (y * 0.5), y) - r / 2;\n}\n\nfunction hexagon(x,y,r){\n     x = abs(x); y = abs(y);\n     return  max((x * 0.5 + y * 0.866025),x) - r;\n}\n\nfunction hexStar(x,y,r) {\n  // rescale to pointy parts of star\n  x = abs(x*1.73205); y = abs(y*1.73205); \n  dot = 2 * min(-0.5*x + 0.866025 * y,0);\n  x -= dot * -0.5; y -= dot * 0.866025;\n  \n  dot = 2 * min(0.866025*x + -0.5 * y,0);\n  x -= dot * 0.866025; y -= dot * -0.5;\n  \n  x -= clamp(x, r * 0.57735, r * 1.73205);\n  y -= r;\n  return signum(y) * hypot(x,y) / 1.73205;\n}\n\n// interior distance on this is slightly weird. Still\n// looking for a reasonable fix.\nfunction cross(x,y,size) {\n  x = abs(x); y = abs(y);\n  \n  if (y > x) { tmp = x; x = y; y = tmp; }\n  qx = x - size; qy = y - size / 5;\n  k = max(qy,qx);\n  if (k > 0) {\n    wx = max(qx,0); wy = max(qy,0);\n    return hypot(wx,wy);\n  } else {\n    wx = max(size - x,0); wy = max(-k,0);\n    return -hypot(wx,wy);\n  }\n}\n\n// UI\nexport function sliderSize(v) {\n  objectSize = 0.4 * v;\n}\n\nexport function sliderFilled(v) {\n  filled = (v >= 0.5);\n}\n\nexport function sliderLineWidth(v){\n  lineWidth = 0.25 * v * v;\n}\n\nexport function beforeRender(delta) {\n  morphClock += delta\n\n// morph to a new shape every other second...\n  if (morphClock > 1000) {\n    if (!wait) {\n      shape = nextShape;                      // set to next shape\n      nextShape = (nextShape+1) % numShapes;  \n    }\n    morphClock = 0;    \n    wait = !wait;\n  }\n\n  lerpPct = morphClock / 1000;\n\n// rotate entire scene\n  theta = PI2 * time(0.1);\n  resetTransform();\n  translate(-0.5,-0.5);  \n  rotate(theta);  \n}\n// You can also project up a dimension. Think of this as mixing in the z value\n// to x and y in order to compose a stack of matrices.\nexport function render3D(index, x, y, z) {\n  x1 = (x - cos(z / 4 * PI2)) / 2\n  y1 = (y - sin(z / 4 * PI2)) / 2\n  render2D(index, x1, y1)\n}\nexport function render2D(index,x,y) {\n  var d;\n  var v = 0;\n\n  // draw one our shapes, interpolating between two SDFs when switching shapes\n  if (wait) {\n    d = shapeSdf[shape](x,y,objectSize);\n  } else {\n    d = shapeSdf[shape](x,y,objectSize) * (1-lerpPct) + shapeSdf[nextShape](x,y,objectSize) * lerpPct;\n  }\n  \n  // fill or just draw boundary based on UI seting.  \n  if (!shapeCompare[filled](d)) {;\n    v = 1-(d/lineWidth);\n    s = 1.5-abs(d)/objectSize\n    h = d + time(0.1);      \n  }\n\n  hsv(h, s, v*v)\n}\n\n"
  },
  "preview": "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"
}