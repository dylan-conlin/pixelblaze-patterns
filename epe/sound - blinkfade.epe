{
  "name": "sound - blinkfade",
  "id": "8pcj483btM54uKnAc",
  "sources": {
    "main": "/*\n  Sound - blink fade\n\n  This pattern is designed to use the sensor expansion board.\n\n  First please check out the \"blink fade\" pattern. With that as background, the\n  goal now is to make it sound reactive.\n\n  We're going to use something called a PI controller to perform an important\n  function common to many sound-reactive patterns: Adjusting the sensitivity\n  (the gain).\n\n  Imagine a person who observes the pixels reacting to sound and is continuously\n  tuning the overall brightness knob to keep things looking good. They would\n  turn the brightness up when the sound is faint and everything's too dark, and\n  turn it down if the sound is loud and the LEDs are pegged too bright. The PI\n  controller is code to perform this job. This form of Automatic Gain Control\n  allows the pattern to adapt over time so it can be in a visual Goldielocks\n  zone, whether the environment's sound is soft, loud, or changing.\n\n  The wikipedia article is more approachable than some:\n\n    https://en.wikipedia.org/wiki/PID_controller#PI_controller\n*/\n\n/*\n  By exporting these special reserved variable names, they will be set to\n  contain data from the sensor board at about 40 Hz. \n\n  By initializing energyAverage to a value that's not possible when the sensor\n  board is connected, we can choose when to simulate sound instead.\n*/\nexport var energyAverage = -1 // Overall loudness across all frequencies\nexport var maxFrequency       // Loudest detected tone with about 39 Hz accuracy\n\nvals = array(pixelCount)\nhues = array(pixelCount)\n\n// The PI controller will work to tune the gain (the sensitivity) to achieve \n// 20% average pixel brightness\ntargetFill = 0.2\n\n/*\n  We'll add up all the pixels' brightnesses values in each frame and store it\n  in brightnessFeedback. The difference between this (per pixel) and targetFill\n  will be the error that the PI controller is attempting to eliminate.\n*/\nbrightnessFeedback = 0   \n\n/*\n  The output of a PI controller is the movement variable, which in our case is\n  the `sensitivity`. Sensitivity can be thought of as the gain applied to the\n  current sound loudness. It's a coefficient found to best chase our targetFill.\n  You can add \"export var\" in front of this to observe it react in the Vars \n  Watch. When the sound gets quieter, you can watch sensitivity rise. If it's\n  always at its maximum value of 150 (ki * max), try increasing the accumulated\n  error's starting value and max in makePIController().\n*/\nsensitivity = 0\n\n/*\n  With these coefficients, it can take up to 20 seconds to fully adjust to a\n  sudden change, for example, from a long period of very loud music to silence.\n  Export this to watch pic[2], the accumulated error.\n*/\npic = makePIController(.05, .15, 300, 0, 1000)\n\n// Makes a new PI Controller \"object\", which is 4 parameters and a state var for\n// the accumulated error\nfunction makePIController(kp, ki, start, min, max) {\n  var pic = array(5)\n  \n  // kp is the proportional gain coefficient - the weight placed on the current \n  // difference between where we are and where we want to be (targetFill)\n  pic[0] = kp\n\n  /*\n    ki is the integral gain - the weight placed on correcting a situation where\n    the proportional corrective pressure isn't enough, so we want to use the\n    fact that time has passed without us approaching our target to step up\n    the corrective pressure.\n  */\n  pic[1] = ki\n\n  /*\n     pic[2] stores the error accumulator (a sum of the historical differences \n     between where we want to be and where we were then). This is an integral,\n     the area under a curve. While you could certainly store historical samples\n     and evict the oldest, it's simpler to just have a min and max for what the\n     area under this curve could be.\n\n     We initialize it to a starting value of 300, and keep it within 0..1000.\n  */\n  pic[2] = start\n  pic[3] = min\n  pic[4] = max\n  return pic\n}\n\n/*\n  Calculate a new output (the manipulated variable `sensitivity`), given\n  feedback about the current error. The error is the difference between the\n  current average brightness and `targetFill`, our desired setpoint.\n\n  Notice that the error can be negative when the LEDs are fuller than desired.\n  This happens when the sensitivity was in a steady state and the sound is now\n  much louder.\n*/\nfunction calcPIController(pic, err) {\n  // Accumulate the error, subject to a min and max\n  pic[2] = clamp(pic[2] + err, pic[3], pic[4])\n\n  // The output of our controller is the new sensitivity. \n  //   sensitivity = Kp * err + Ki * ∫err \n  // Notice that with Ki = 0.15 and a max of 1000, the output range is 0..150.\n  return max(pic[0] * err + pic[1] * pic[2], .3)\n}\n\nexport function beforeRender(delta) {\n  sensitivity = calcPIController(pic,\n                  targetFill - brightnessFeedback / pixelCount)\n\n  // Reset the brightnessFeedback between each frame\n  brightnessFeedback = 0\n  \n  if (energyAverage == -1) { // No sensor board is connected\n    simulateSound()\n  } else {                   // Load the live data from the sensor board\n    _energyAverage = energyAverage\n    _maxFrequency = maxFrequency\n  }\n\n  for (i = 0; i < pixelCount; i++) {\n    // Decay the brightness of each pixel proportional to how much time has\n    // passed as well as how loud it is right now\n    vals[i] -= .0005 * delta + abs(_energyAverage * sensitivity / 5000)\n\n    // If a pixel has faded out, reset it with a random brightness value that is\n    // scaled by the detected loudness and the computed sensitivity\n    if (vals[i] <= 0) {\n      vals[i] = random(1) * _energyAverage * sensitivity \n\n      /*\n        The reinitialized pixel's color will be selected from a rotating \n        pallette. The base hue cycles through the hue wheel every 4.6 seconds.\n        Then, up to 20% hue variation is added based on the loudest frequency\n        present. More varied sound produces more varied colors.\n      */\n      hues[i] = time(.07) + .2 * triangle(_maxFrequency / 1000)\n    }\n  }\n}\n\nexport function render(index) {\n  v = vals[index]\n  v = v * v  // This could also go below the feedback calculation\n  \n  /*\n    Accumulate the brightness value from this pixel into an overall sum that \n    will be averaged across all pixels. This average will be fed back into the\n    PI controller so it can adjust the sensitivity continuously, trying to make\n    the average v equal the targetFill of 0.2.\n  */\n  brightnessFeedback += clamp(v, 0, 1)\n\n  hsv(hues[index], 1, v)\n}\n\n\n\n/*\n  These functions are used if the sensor board is not detected to simulate the\n  sound variables used in this pattern. This allows the pattern still be lively \n  in the sequencer when there's no sensor board connected.\n  \n  16th notes (sequencerSlot)       S                              S\n  SB samples @40Hz (timeSlots)     T      T      T      T      T\n  beforeRender() e.g.~150FPS       B B B B B B B B B B B B B B B B B\n  \n  We cache the semi-random simulated data at the timeSlot level.\n*/\n\nBPM = 130  // Tempo in Beats Per Minute\nvar measurePeriod = 4 * 60 / BPM  // Seconds per 4 beat measure\nvar samplesPerMeasure = ceil(measurePeriod * 40)  // SB updates at 40Hz\n\n// These globals store the simulated versions of the sensor data\nvar _energyAverage = 0, _maxFrequency = 0, _maxFrequencyMagnitude = 0\nvar _frequencyData = array(32)\n\n// Lookup table of frequencyData center frequencies\nvar freqs = array(32)\nfreqs[0] = 37.5; freqs[1] = 50; freqs[2] = 75; freqs[3] = 100; freqs[4] = 125; freqs[5] = 163; freqs[6] = 195; freqs[7] = 234; freqs[8] = 312; freqs[9] = 391; freqs[10] = 469; freqs[11] = 586; freqs[12] = 703; freqs[13] = 859; freqs[14] = 976; freqs[15] = 1170; freqs[16] = 1370; freqs[17] = 1560; freqs[18] = 1800; freqs[19] = 2070; freqs[20] = 2380; freqs[21] = 2730; freqs[22] = 3120; freqs[23] = 3590; freqs[24] = 4100; freqs[25] = 4650; freqs[26] = 5310; freqs[27] = 6020; freqs[28] = 6840; freqs[29] = 7770; freqs[30] = 8790; freqs[31] = 9960\n\nvar beat, beatPct, timeSlot, sequencerPos, sequencerSlot\nfunction calcSequencerTime() {\n  t1 = time(measurePeriod / 65.536)   // 0-1 every measure\n  beat = floor(t1 * 4)                // 0, 1, 2, 3\n  beatPct = t1 * 4 % 1                // 0-1.0 continuous for every beat\n  // There are samplesPerMeasure 40Hz timeSlots in each measure\n  timeSlot = floor(t1 * samplesPerMeasure)\n  sequencerPos = 16 * t1              // can be fractional 0..15.999\n  sequencerSlot = floor(sequencerPos) // 0-15 every measure\n}\n\n// Calculate and memoize all simulated sensor board sound data\nvar cachedTimeSlot = -1\nfunction simulateSound() {\n  calcSequencerTime() \n  if (timeSlot == cachedTimeSlot) return // 140FPS -> 208FPS\n  \n  var energyTotal = 0, maxBin = 0, maxBinEnergy = 0\n  for (fBin = 0; fBin < 32; fBin++) {\n    binEnergy = simulateFrequencyData(fBin)\n    energyTotal += binEnergy\n    if (binEnergy > maxBinEnergy) {\n      maxBin = fBin; maxBinEnergy = binEnergy\n    }\n  }\n  _energyAverage = energyTotal / 32\n  _maxFrequency = binomSample(freqs[maxBin], 8)\n  _maxFrequencyMagnitude = binomSample(maxBinEnergy, 8)\n  cachedTimeSlot = timeSlot\n}\n\n\nvar instrumentCount = 4\nvar instruments = array(instrumentCount)\ninstruments[0] = makeInstrument(0b1000100010001000, 1, 3, 0.01)    // kick drum\ninstruments[1] = makeInstrument(0b1001001010001000, 5, 2, 0.01)    // bass\ninstruments[2] = makeInstrument(0b1011101000011100, 10, 6, 0.01)   // lead synth\ninstruments[3] = makeInstrument(0b0010001100100011, 20, 13, 0.05)  // high hat\n\nfunction makeInstrument(sequence, centerBin, bandwidth, magnitude) {\n  inst = array(4)\n  inst[0] = sequence   // 16 slot binary vector sequencer\n  inst[1] = centerBin  // center freq (bin index)\n  inst[2] = bandwidth  // half-bandwidth, in bins. Further bins are attenuated.\n  // Max instrument magnitude, if right on the sequencer attack and centerBin\n  inst[3] = magnitude    \n  return inst\n}\n\n// For the current 40Hz timeSlot, simulate a _frequencyData[fBin]\nfunction simulateFrequencyData(fBin) {\n  slotProximity = 1 - sequencerPos % 1 // Directly on-beat = 1. The D in ADSR.\n  var fDataBinSum = 0, binProximity = 0\n  for (inst = 0; inst < instrumentCount; inst++) {\n    // If this instrument is \"on\" in this sequencer slot\n    if ((instruments[inst][0] >> (15 - sequencerSlot)) & 1) {\n      // How close we are to the center frequency bin of the instrument\n      binProximity = max(0, 1 - abs(fBin - instruments[inst][1]) / instruments[inst][2])\n      // Add some energy to this bin that's statistically close to the\n      // instrument's nominal energy magnitude, decayed and splayed across bins\n      fDataBinSum += binomSample(instruments[inst][3], 3) * slotProximity * binProximity\n    }\n  }\n  return _frequencyData[fBin] = fDataBinSum\n}\n\n/*\n  Returns a sample from a binomial distribution centered around a mean. Binomial\n  approaches a discrete normal distribution (a bell curve). Takes a whole number\n  `concentration` that determines how close the result usually is to the mean. A\n  high concentration implies low variance around the mean. concentration == 1\n  means it was selected from a flat distribution within +/- 50% of the mean.\n*/\nfunction binomSample(mean, concentration) {\n  sum = 0\n  for (i = 0; i < concentration; i++) sum += random(1)\n  return mean * (0.5 + sum / concentration)\n}\n"
  },
  "preview": "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"
}