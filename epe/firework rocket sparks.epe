{
  "name": "firework rocket sparks",
  "id": "u8ucBpiY7imGTmMpr",
  "sources": {
    "main": "/*\n  In this patterns we'll learn some techniques to send an object across the strip.\n  \n  Our goal is to have a fiery rocket (oranges and reds) followed by a sparkling\n  white tail.\n  \n  You'll learn some convenient tricks for animating things in Pixelblaze. You \n  might be thinking, \"OK, I'll store a position for the head of the rocket. \n  The pixel should be red if it's a little behiind that, then some sparks, \n  then dark. Then I'll advance that positon between frames.\" While you could \n  build it that way, this pattern helps you start you thinking in terms of,\n  \"Everything's a wave or derivative of one.\" \n  \n  This is an imperfect pattern, so as you read through, see if you can spot\n  quirks. At the end there's a section that discusses possible improvements.\n*/\n\nexport function beforeRender(delta) {\n  // time() outputs a sawtooth from 0..1. An argument of 0.05 means it takes \n  // 0.05 * 65.536 seconds to progress to 1 before looping back to 0.\n  t1 = time(0.05)\n}\n\nexport function render(index) {\n  // Start with a sine wave traveling left (because adding an offset like t1 \n  // is a left shift). The amplitude goes from 0..1, and the wavelength is the \n  // entire strip.\n  v = wave(index / pixelCount + t1)\n  \n  // To make a fiery rocket, set up a second wave that will lead by 10 pixels\n  v2 = wave((index + 10) / pixelCount + t1)\n\n  // When the rocket fire's 0-to-1 siusoid wave is any value from 0.9995 to 1 \n  // (the very top of the curve), isFire will be 1 (true).\n  isFire = (v2 > .9995)\n  \n  /*\n    First, `*=` is multiplication assignment; it just means update a variable by\n    multiplying it by whatever is on the right side. \n    `v *= k` is the same as `v = v * k`.\n    \n    A convenient trick is to multiply a value by a boolean. In this way, a \n    \"false\" conditional is cast to be zero, and multiplying a numeric value by\n    it will zero out that value. \n    \n    This statement creates the sparkling tail section. If we're in a part\n    of the main wave where the top of the sinusoid is within 0.05 of it's max\n    value (1), AND a random value between 0 and 1 is greater than 0.95 (a 5% \n    chance), then keep this high value that's above 0.95. Otherwise, zero it out.\n    Another way of thinking about this line is, \"For the sparks, make a tail\n    from the top of a sinusoid that comprises about the 20% of the strips length,\n    and randomly turn on those pixels 5% of the time.\n  */\n  v *= (v > .95 && random(1) > .95)\n\n  /*\n    Now we'll set our hues for the fiery section. We want something between \n    hue 0 (red) and hue 0.2 (yellow).\n\n    You might think, how about making it yellow up front, and the redish portion\n    trails behind, all of it moving along with the rocket. We could do that, but\n    the alternate approach used here sort of simulates fire being expelled from\n    a rocket instead. The red-to-yellow sawtooth gradient is only a function of\n    the pixel's position in the strip. That way, as the rocket moves through \n    space, it leaves a trail behind it instead of \"taking\" the plume with it.\n    \n    The \"%\" is the remainder operation.  so we'll get a repeating sequence\n    of 0, .05, .1, and 0.15.\n  \n    As you'll see in a second, for a spark, this hue will be ignored because \n    sparks will have their saturation set to zero. A zero saturation makes the \n    pixel white no matter what the hue is.\n  */\n  h = (index / 20) % .2\n\n  /*\n    Let's put it all together with hsv(hue, saturation, value). \n    \n    The final color of a pixel will be either:\n      - black (because value is zero)\n      - white (because value is high and saturation is zero), or \n      - red-yellow (because value is high and saturation is high)\n      \n    h will always be a red-yellow hue\n    \n    isFire will be 1 of the fire pixels and 0 for sparks or off pixels. That\n    means we'll saturate (color) for fire, and desaturate (white) for a spark.\n    \n    Finally, for value, we want it to be ON (a high value) if it's EITHER a fire\n    pixel OR a spark pixel. hsv() conveniently accepts values larger than 1 and\n    treats them as 1, so we can composite the two types of pixels we want on with\n    by adding the boolean isFire (1 or 0) to the v for sparks (which you'll \n    recall is a high value above 0.95; basically all the way on for a spark).\n    Sometimes we'll have a 1.97 for example; this pixel is a random spark within \n    the fire. This will be red-yellow, because the saturation of this pixel is 1.\n    \n    For binary values, clamped addition is an \"OR\" and multiplication is an \"AND\".\n    \n    hsv clamps v values to within 0 and 1, so you can also pass in brightness values\n    less than 0 and it will have a brightness of 0 instead of throwing an error.\n  */\n  hsv(h, isFire, isFire + v)\n}\n\n/*\n  OK, so how could it be improved? Well, you might notice we have mixed concepts\n  when is comes to specifying an offset or width. \n  \n  Sometimes we use a fairly standard method of thinking in terms of the \n  \"percentage of the strip\". Every time we see an `index/pixelCount` this is the\n  \"fractonal percentage of the strip's total width\". Doing our math this way\n  ensures strips of different length will display patterns nearly identically\n  in proportion to the overall length. For example, \n  \n    t1 = time(0.05)\n    v = wave(index / pixelCount + t1)\n    \n  This ensures the rocket will loop every 3.3 seconds when t1 returns to 0,\n  regardless of whether we have 10 pixels or 1000.\n  \n  In this pattern, the width of the sparking portion is determined similarly - \n  it's a constant percentage of the strip's overall length:\n  \n    v = wave(index / pixelCount + t1)\n    v > .95  // Spark-eligible\n    // See https://www.desmos.com/calculator/mnipavu3mk\n  \n  That's all good, but notice that two other elements are defined in number of \n  pixels instead. First, the fire's offset from the sparks is 10 pixels:\n  \n    v = wave(index / pixelCount + t1) // Peaks of this wave will be sparks\n    v2 = wave((index + 10) / pixelCount + t1) // Peaks will be fire\n  \n  Second, the fire colors repeat every 4 pixels:\n  \n    h = (index / 20) % .2  // Same as `(index % 4) / 20`\n  \n  How does this affect us in real life? Well on long strips (e.g. 240 pixels\n  in a 4 m * 60 pix/m), sparks can preceed the fire. At farther viewing\n  distances, the 4-pixel fire gradient blends into just orange.\n  \n  Another interesting case is binking a random pixel in render() with \n  something equivalent to:\n  \n    hsv(0, 0, random(1) > 0.95)\n\n  In addition to depending on the probability used, the final perceptual effect \n  will both depend on the number of pixels and on the speed (frames per second)\n  that your pattern is running at. If you wanted to precisely scale how this \n  looks on a strip that's 10X more pixels and maintain the effect, you might \n  choose to blink groups of a few pixels together; In addition it might be \n  running 10X slower, so the minimum blink duration will be 10X longer.\n  \n  One last note: Notice how we use the tops of wave(), essentially:\n  \n    wave(index / pixelCount + t1) > 0.95 // spark eligible\n    \n  Since we never end up using the sinusoidal nature of the values much, it\n  might be clearer and easier to use the square() function:\n  \n    square(index / pixelCount + t1, 0.144)\n  \n  This way we can just read off that 14.4% of the strip can spark, instead of\n  wondering what percentage of wave() is above 0.95.\n  \n  \n  When you take out the comments, this is a small 7-line pattern. It also \n  uses a variety of useful Pixelblaze techniques.\n*/"
  },
  "preview": "/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCACWAGQDASIAAhEBAxEB/8QAHAABAAMAAwEBAAAAAAAAAAAAAAQFBgIDBwEJ/8QALBAAAgICAgICAgIBBAMBAAAAAgMBBAAFBhIREwcUISIVMRYXIzJBJEJhc//EABkBAQEBAQEBAAAAAAAAAAAAAAAEAwUCAf/EAC8RAAEDAwMCBQMDBQAAAAAAAAEAAgMRITEEQVESgRMiYXGRFCMyQlKhcrHR8PH/2gAMAwEAAhEDEQA/APy//wAjsV9d9KgP8Ut9L6Owmk9w/wAmH2PsRNgZORLwQpiBGBD/AMdRde8SZVWMYRMYxhExjGETGMYRMYy64Xwvd/IvKtZxrjetdt95snQirTREdmFP5/MzMQIxESREUwIjEzMxETOZySMiYZJCA0CpJsABkk7AL6ASaBRuPcb2/LtzW1Gi1d3dbWzJQijrq5ve3wMlPVYRJF4GJmfEf1Ez/wBZpmCXFOMuscf+5atEP0N3vkL81K02QKQopZ1/UjWmxBs7R7RhqwiVAZv3dnWXuO8A1eu+MdJyHbWN2+ePb7mNGm4q+0u2IUY6WnIjMeBEY8xE+yxJl+PV1ifN+QWK+z4To9gadevalds03FUSlDCQmtSBHda3f/pPsmuuWGTSJ1g5OE8+Iv1v3JG9MewOTm7hsDlozu6h8ovlY3SHoBq+4PAyCBkG1LjtysrjGM6i56YxjCJjGMImMYwiYxmp+NPjfcfKvK6+h031kmQE+1fvuhFOhWCPLbNhs/halj+SKf8A5ERJTETjNNHp43TSu6WtFSTgBemtc8hrRUqn49x7Ycq3NbV6xEWLj5LrBMFYAIjJGxjDmBWsBEjNhzAgIkRTAxMxabfd6/X6ZWm0ItEWL8bTZkZCewKSA4VAefA11kAyAzHYyiWHMf7a02XM+TceRrKOj4br3Uaq6gp224e5n2N07uLCk19uikAYj61iMTPQTZJFAwFPzXVce0+1UjjW/scjokmGnbsa6aUgREUivpLDmSFcrhk+esN9oATVgDmyx9WppLI0taMNOd7uoe7WnGT5qBtclNMTG01dgkG24IBBoQRk74Frui1mbPldzSac7/u9fXX0B2N4U16oG4j6QxpCtC/Y5hlMyIRJmRTHkpyqyUzbXnaqvrGXLB62s5tlFMmlKVNYKxYwQ8+BIxSqCKI8zCwifPWPEXOgokxjGETGMYRMYxhExjNn8V/HH+o/IGJubirxnjtBX3Nxv7wySdfWiYiTgI/ZrCmYFah/ZhkIx4/MxhPPHponTSmjR3+ALknAAuTYXWkcb5XdDBU/4ufgXPAuqTi3GLHK9nNZT69GsoJfc2N0iGtSRExBOaQxM9YkhiBESMyIQATMxEt1tStaJA8bXp9gvj+pGH8u1dFLKm0CQuihwbB7K8wkvYKIWHhiEy1ETBvlsnlrPJtS4tJq/wCKaPGaLxbcXWaCL2xKZH2sOxKzgCkYkVj1NaYn8CZk021Yb/272hsr+t1+xXV+sJ68kfWr2VpEAhbIryov3EIgzEhYckRyfcpPMWxGdwkmFhgcep9f7e6o8Q6erYje4JHrUEAjYg35xjMTbXE7Ha3LdehX1aHuNq6NQmEmsJFMwsJYZnIjE+IkzIvER5KZ8zLZ7a9urIWNhcsX7AJTWFtlpMIVKWKlLiSmZgQWAAI/0IiMR4iIjG2uJ2O1uW69Cvq0PcbV0ahMJNYSKZhYSwzORGJ8RJmReIjyUz5mYuWqNMYxhExjGETGMYRMYzbcA+O63Iqtrdck27OK8QqA6D2/05snZsAIzFSqrsEOfMsVMj3GAAu5kI+PM888emYZJTb2JJ9ABUk8AAkrWKJ8zuiMVNz2AqT7ACpOwVJxTj9beXTPZbEdPpqowy7flftMA/6BSuw+1xf0C+wxM+ZIlrE2Bqd18l0d/wAU4Vx6zROrxzRXnssaLUrCqVkGSmTtHdOWky20RJckSfWoUq6BMEQDF+RKu2pqnTPKrR1vG2qplphMq7qlxyu1iG13it7LAmglWHeuRE1LXBQqK45j9Ttr2g2tPZ6y5Y12ypOCzVuVGkpyGgUEDAMZiRISiJgomJiYiYzEQeM9s04u01aM9ORX+og0OwwNy7V0nhAxxH3POcWBAptvk7AS/wCS/wAa5V9/jG12Cf4+779XtOv07g9D7Jd4Ww/S2PAl4FhdS/op8eccp5TtOab21ut1a+9tbXWbNsliLLBwMDLWSMR3aXXsbC8mw5IzIjIimqxlylTGMYRMYxhExjGETGM2ul+Pj1+h1PL+WV7lDh19tgKZoIQsbZiJXDE1u0F1jy0BJ5DKw8H4hhhCSnmnjgALzc2A3JoTQDc0BPsCcBaMjdIaNH/F0cC4TO/v6+xsKW0s6y1a+nUqapBHb29uJX4o1J6FHtmXK7FIl6xYJdGES1Mu2fKlvlKqyt26jW0nHNDZ1+m48hMDXE3r9BEkDQ8PdJt+yxrOpl6S6OWyESOSs3tlze8hTHVlhRpMCrXbYXVr1q6QNsqX3IR8z4YUD5k2tOf+bWftzocqGOTbLc7GjXsneTeE0VKtWukG2ENASBMoNSxA2QUCtYyMDEKJJQDAxbpw+QTzirhjhuRb1INCfcYWr5A1pijxueaV7genc3x937NNS1S9LSr172yo7O6TeS1LD/TsqpCgK4AhoBKxAlPZBEImUWYgxH1xGZ/JW2ZRdtLjNZXsVNabjKrXtvF7lKkp6CbBAIMoHxElABEzEzAj58RFy5TJjGMImMYwiYxjCJjGMIvRPjjj3GtG+jyj5Er2bHGpW2zR0dRvqs71ijEIVBx+yK8nJQViY/MKcCuzAKAmci+QNlsdVxvdbRe54/yzXAVzjm9pSxam1FurpqV649wGsqsdbYHD09yJxSJREwTBo7PPDpa7TW9TsdmvlYWlbC3tiBKTpNr+V0lUmhEuUKl/tJCwBKSUEKH6oMPP8X/hI3tYuR/yBaYOxvVq+kWHdRmRUBn5FfcoEJbIn64KT9bZH1lBFpaSnUSmrzYcNHDff9Ry6gwAGiuSf7fgR2ZWvq4itCbm4BoALD1NSYtOmm1XvMZer1DrphqkuFklaKWAHrX1AogoEyZ5OQHqsv2kpESi4xl6kTGMYRMYxhExjGETGMsePce2HKtzW1esRFi4+S6wTBWACIyRsYw5gVrARIzYcwICJEUwMTMeXvbG0veaAXJOy+gEmgVdjN/reZ8R4rSVQVwPTcyaIwdja76xsVGbZ/5CldW0kQSP4ge8EZTBHMjBwpbOcdZKD5dO8jnyCvYvB+QDyFq6MNJaXC3f+RY9rLFa24mhZNj6FfYgSWqhNkmQIkayAWR6zGeyyKGDEzIyQD2Ex7DMXJW2217fbS5s9ncsbHZXXHZtXLbSa57TKSNhmUzJERTMyUzMzMzM5FzprFMYxhExjGETGMYRMYy44txixyvZzWU+vRrKCX3NjdIhrUkRMQTmkMTPWJIYgREjMiEAEzMRLw97Y2l7zQBfQC40Ck8D4Rd+QeS1dRTs0NcLCGbGz21oatGiqSEZdYcX4WuJIY8/mZkhEYIiEZ1u/wCc8ZLUaDhehRa0nF1GM7/foRDtluGGSyawlywBJKvXHorSYx5iTMoNkyNJyc688P1aaTdZQoL6OTTFsO2OwM5cttqwS4KFdCr9RrsIJAHKJYM9rnsrJ2xcVs6dmju117fXuXs08h1DbSbK2ktDAV2OQgCrsEog1hE+yWTDGBCijn/Tu1ErZp8Nu1vBv5je5pgYab3NCLhN9O10cX5GxcOLggEHBBvzjFa7TX/BvyF8jcR4xteH8J5BzDXDSah1nj3H4sBWdFuxMpa2r7CNvUgPzZgHQDVjA+kUmbPNblxNqvRWujXqHWTKmuSTJK0UsM/YzsZRBQJivwEAPVY/rJSREzpqBRcYxhExjGETGMYRMYy74px+tvLpnstiOn01UYZdvyv2mAf9ApXYfa4v6BfYYmfMkS1ibAzkkbE0vdgd/wCBcngC52XtjHPPS0VP+1+N1cfFfxx/qPyBibm4q8Z47QV9zcb+8MknX1omIk4CP2awpmBWof2YZCMePzMWnIeTanUXaWtbwMtfq6Vepdq6y61qT2LTiuz7V4/EOap9ft0WliRXFgTUUeWS6q5ryzft0en4ldoTodDrYjY0dTNWEnM2kJL7TDkYNxOUKTgzmR6lHrgFyIxWXuPDxyvsx2g17diHP11U9ZuargVZSxMsYYr9ktRKzMQMZAGEXYGHCjCYIoZZJfH1Bx+LQbDNzy4jOQ3Da3c6x8rIo/Chzu7nI8u4aQbg3JzsA1Nq9eZSuFoa+81vHEg63XimS0lW+1Hn7bK/rZIk2wKvaTIOIYtYmPhcRVbO4m/ZBiKFfXAKVKlNYmSJECxAmT7DKezCGWFETAwRl1EB6jDbMou2lxmsr2KmtNxlVr23i9ylSU9BNggEGUD4iSgAiZiZgR8+Ii501AmMYwiYxjCJjGMImMZv/i34/wBVvbH89zS/a4/wCkRzb2FZPaxdMICZpUoL9TslDF/3PVYn7D/WPBTajUR6WMyyYGwFSTwALknYC5W0UL53dEYqbnsBUn2AFSdguj45+Kb/ADxi7LWN12oKwNRVgKjLL79mTUP06KQjzZtzDgkUwQx+wyZrGe2R6/yhtNXsNK3W1tamhpRbFDV39dX2FQTaEA5zUWFmtzmRAyTDCZ/RcD0FShDhzz5L2vPK+l17+lHQaKtNTU6ar+temEzEsKI/9msKO7Gz+xl/f4gRGDs9Cmvx4LVFNjZBWcob26rSyaKysVxYipImkJW8CVcEpkyFnrL1xIrljJ9PHLIfG1VOqtm5DRcZ3cRk4Fw21S7ed0TPtQmoGXfuIJuKgENpSxuaVN6AReU7r/I97Z2ps2D7Vzq+5Z2lz7dixaIYmw429BmfY32HETEkMFAkRzEmUTbba9v9rc2ezuWNjsrrjs2rltpNc9plJGwzKZkiIpmZKZmZmZmclbHlGz2mi1GmsWfOq1XumpUWsVgBtKCa0oGI7sLqAyw/JyClB26KWI1edFRJjGMImMYwiYxjCJjGMItLwbjtHdWNpe2x2P4XS042N5NIhGy9fuUkVKIokQImPXEmUFADJH0ZIws+VrlCOVO0NLeBGv11J3oK7rUE59elMh/tKrk4FFC5hzRjysmMe0mtKSghYznx+fVSdV+mlPSoNflVO8sTQN89ly4Jw/8Azxux1FMPXuVU7m3Xafa6Vwq0qNq3aXK4UREwxSPrKCEYkZgomDgl5bGM6ClTGMYRMYxhExjGEX//2Q=="
}