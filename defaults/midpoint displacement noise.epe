{
  "name": "midpoint displacement noise",
  "id": "36h5YYz2jeCqkiZjj",
  "sources": {
    "main": "/*\n  Midpoint displacement noise\n  \n  Recursive midpoint displacement to generate a pseudo-random 1D height map.\n\n  It turns out that when composing computer graphics, there's a persistent need\n  for randomness if we want to make things appear more \"organic\". Generating any\n  individual random number is easy using `random()`. A sequence of purely random\n  values is white noise, which hops all around. In computer graphics, we \n  commonly have a need for a continuous noise functions that can be procedurally\n  generated, known as value noise or gradient noise. If you think of the\n  continuous but random set of heights encountered while transiting a mountain\n  range, that would be analogous to gradient noise, and could be represented as\n  a 1-dimensional height map. A topo map is a representation of a 2-dimensional\n  height map.\n\n  In 1983, Ken Perlin invented an algorithm for his work on the movie Tron,\n  which is now known as Perlin noise. In 2001, he extended that work into an\n  n-dimensional approach called Simplex noise.\n\n  In 1982, however, Fournier, Fussell and Carpenter (a cofounder of Pixar)\n  published a paper on a value noise procedure which is now known as the\n  diamond-square algorithm, or more appropriately in 1 dimension, \"midpoint\n  displacement\". This is faster than Perlin, and is therefore provided in the \n  Pixelblaze examples for those who want to incorporate a more organic noise in\n  their patterns. You can find a Perlin and Simplex noise generator in the\n  pattern library.\n\n  Generously contributed by zranger1 (Jon) from the Pixelblaze forums.\n    https://github.com/zranger1\n*/\n\n\nvar heightMap = array(pixelCount)\nvar maxDisplacement = 10  // Maximum height change at level 1\n\n/* \n  Initial parameters chosen by eyeball. Many interesting things are\n  possible, so please play with the sliders! Palette width and offset\n  are good places to start. The relevant variables are exported so you can\n  watch them in your browser.\n*/\nexport var speed = .03         // .015 = 1 palette cycle / second\nexport var smoothness = .2     // Change in max displacement per level\nexport var paletteWidth = .15\nexport var paletteOffset = 0 \nexport var mapLifetime = 5000  // In milliseconds, 0 == forever\nexport var maxLevel = calcMaxRecursionDepth()\n\n// Globals for animation\nvar t1\nvar xOffset\nvar mapTimer = 0\n\n// Max recursion depth is the power of 2 nearest to, but less than pixelCount.\n// The absolute max is 7 -- above that, current Pixelblazes will not go.  \nfunction calcMaxRecursionDepth() {\n  return min(7, floor(log2(pixelCount)))\n}\n\nfunction triggerNewMap() { mapTimer = mapLifetime }\n\n// UI Controls\nexport function sliderMaxLevel(v) {\n  maxLevel = floor(calcMaxRecursionDepth() * v)\n  triggerNewMap()\n}\n\nexport function slidermapLifetime(v) {\n  mapLifetime = floor(30000 * v)\n  triggerNewMap()\n}\n\nexport function sliderSpeed(v) {\n  speed = 0.1 * (1-v)\n}\n\nexport function sliderPaletteWidth(v) { paletteWidth = v }\n\nexport function sliderPaletteOffset(v) { paletteOffset = v }\n\nexport function sliderRoughness(v) {\n  smoothness = 0.3 + 2.7 * (1 - v)\n  triggerNewMap()\n}\n\n// Calculate random offset proportional to current level\nfunction displace(level) {\n   var d = 2 * maxDisplacement / pow(smoothness, level)\n   return d - random(2 * d)\n}\n\n// Displace initial segment endpoints and draw a smooth line between them\nfunction initialize() {\n  heightMap[0] = displace(1)\n  heightMap[pixelCount - 1] = displace(1)\n  interpolate(0, pixelCount)\n}\n\n// Rescale height map to range 0-1\nfunction normalize() {\n  var hMax, hMin, range\n  \n  hMax = -32000\n  hMin = 32000\n  \n  for (i = 0; i < pixelCount; i++) {\n    if (heightMap[i] > hMax) { hMax = heightMap[i] }\n    if (heightMap[i] < hMin) { hMin = heightMap[i] }       \n  }\n  range = hMax - hMin\n  \n  for (i = 0; i < pixelCount; i++) {\n    heightMap[i] = (heightMap[i] - hMin) / range\n  }\n}\n\n// Line between segment endpoints\nfunction interpolate(start, nPix) {\n  var m = (heightMap[start + nPix - 1] - heightMap[start]) / nPix\n  \n  for (c = 1; c < nPix; c++) {\n    heightMap[start + c] = heightMap[start] + m * c\n  }\n}\n\n// Given a segment, find and displace midpoint, then subdivide and repeat for\n// each new segment\nfunction subdivide(indexStart, nPix, level) {\n  var newLen, indexMid\n          \n  // If we can't subdivide further, we're done \n  if (level > maxLevel) { return }\n\n  // Find midpoint and add random height displacement\n  newLen = floor(nPix / 2)\n  indexMid = indexStart + newLen - 1\n  heightMap[indexMid] += displace(level)\n    \n  interpolate(indexStart, newLen)\n  interpolate(indexMid, 1 + nPix - newLen)\n\n// Recursion! Do the same thing with our two new line segments.\n    level += 1\n    subdivide(indexStart, newLen, level)\n    subdivide(indexMid, 1 + nPix - newLen, level)\n}\n\n// Create initial heightmap\ninitialize()\nsubdivide(0, pixelCount, 1)\nnormalize()  \n\n\nexport function beforeRender(delta) {\n  mapTimer += delta\n\n  t1 = time(speed)\n\n  // Generate new height map every `mapLifetime` milliseconds, where setting\n  // mapLifetime to 0 == forever\n   if (mapLifetime && (mapTimer > mapLifetime)) {\n     mapTimer = 0\n\n     initialize()\n     subdivide(0, pixelCount, 1)\n     normalize()\n   }\n}\n\n// Render heightmap and do something inexpensive to animate \nexport function render(index) {\n  var v = heightMap[index]\n  var h = (v + t1) % 1\n  h = paletteOffset + (h * paletteWidth)\n  hsv(perceptualH(h), 1, v * v)\n}\n\n// Utility to map HSV's hue into a more perceptually uniform rainbow\nfunction perceptualH(pH) {\n  pH = pH % 1 + (pH < 0)\n  return wave((pH - .5) / 2)\n}"
  },
  "preview": "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"
}