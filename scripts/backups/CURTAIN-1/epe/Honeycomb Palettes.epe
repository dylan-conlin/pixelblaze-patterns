{
  "name": "Honeycomb Palettes",
  "id": "wJYNZn9QJgv4CHQPL",
  "sources": {
    "main": "/*\n  Honeycomb 2D - with dynamic palettes\n  This code takes the Honeycomb 2d code and makes it rotate between different \n  palettes. It is based on the original Honeycomb 2D code, merged together and tweaked \n  by ZacharyRD with ZRanger1's Gradient Palette Blending Demo code, both \n  available in the PixelBlaze Pattern Library. \n\n  This pattern is meant to be displayed on an LED matrix or other 2D surface\n  defined in the Mapper tab, but also has 1D and 3D renderers defined.\n  \n  Output demo: https://youtu.be/u9z8_XGe684\n  \n  The mapper allows us to share patterns that work in 2D or 3D space without the\n  pattern code being dependent on how the LEDs were wired or placed in space.\n  That means these three installations could all render the same pattern after\n  defining their specific LED placements in the mapper:\n    \n    1. A 8x8 matrix in a perfect grid, wired the common zigzag way\n    2. Individual pixels on a strand mounted in a triangle hexagon grid\n    3. Equal length strips wired as vertical columns on separate channels\n         of the output expander board\n  \n  To get started quickly with matrices, there's an inexpensive 8x8 on the \n  Pixelblaze store. Load the default Matrix example in the mapper and you're\n  ready to go. \n\n  This pattern builds on the example \"pulse 2D\". To best understand this one,\n  start there.\n*/\n\n/* Each palette is created with http://fastled.io/tools/paletteknife/ and \nhttp://soliton.vm.bytemark.co.uk/pub/cpt-city/index.html , then normalized \nto 0.0 to 1.0 range. \n*/\n\n//http://soliton.vm.bytemark.co.uk/pub/cpt-city/nd/basic/tn/BlacK_Blue_Magenta_White.png.index.html\n//black-blue-purple-pink-white\nvar black_Blue_Magenta_White_gp = [\n    0,   0,  0,  0,\n   42,   0,  0, 45,\n   84,   0,  0,255,\n  127,  42,  0,255,\n  170, 255,  0,255,\n  212, 255, 55,255,\n  255, 255,255,255]\n  \narrayMutate(black_Blue_Magenta_White_gp,(v, i ,a) => v / 255);  \n\n//http://soliton.vm.bytemark.co.uk/pub/cpt-city/es/landscape/tn/es_landscape_33.png.index.html\n//brown-yellow-forest-green\nvar es_landscape_33_gp = [\n    0,   1,  5,  0,\n   19,  32, 23,  1,\n   38, 161, 55,  1,\n   63, 229,144,  1,\n   66,  39,142, 74,\n  255,   1,  4,  1]\n  \narrayMutate(es_landscape_33_gp,(v, i ,a) => v / 255);\n\n//http://soliton.vm.bytemark.co.uk/pub/cpt-city/bhw/bhw1/tn/bhw1_05.png.index.html\n//teal to purple\nvar bhw1_05_gp = [\n    0,   1,221, 53,\n  255,  73,  3,178]\n\narrayMutate(bhw1_05_gp,(v, i ,a) => v / 255);\n\n//http://soliton.vm.bytemark.co.uk/pub/cpt-city/bhw/bhw1/tn/bhw1_04.png.index.html\n//yellow-orange-purple-navy\nvar bhw1_04_gp = [\n    0, 229,227,  1,\n   15, 227,101,  3,\n  142,  40,  1, 80,\n  198,  17,  1, 79,\n  255,   0,  0, 45]\n\narrayMutate(bhw1_04_gp,(v, i ,a) => v / 255);\n\n//http://soliton.vm.bytemark.co.uk/pub/cpt-city/nd/atmospheric/tn/Sunset_Real.png.index.html\n//red-orange-pink-purple-blue\nvar Sunset_Real_gp = [\n    0, 120,  0,  0,\n   22, 179, 22,  0,\n   51, 255,104,  0,\n   85, 167, 22, 18,\n  135, 100,  0,103,\n  198,  16,  0,130,\n  255,   0,  0,160]\n\narrayMutate(Sunset_Real_gp,(v, i ,a) => v / 255);\n\n// http://soliton.vm.bytemark.co.uk/pub/cpt-city/nd/red/tn/Analogous_3.png.index.html\n//purple pink red, with more purple than red. \nvar Analogous_3_gp = [\n    0,  67, 55,255,\n   63,  74, 25,255,\n  127,  83,  7,255,\n  191, 153,  1, 45,\n  255, 255,  0,  0]\n\narrayMutate(Analogous_3_gp,(v, i ,a) => v / 255);\n\n// http://soliton.vm.bytemark.co.uk/pub/cpt-city/nd/red/tn/Analogous_1.png.index.html\n//blue-purple-red evenly split out. \nvar Analogous_1_gp = [\n    0,   3,  0,255,\n   63,  23,  0,255,\n  127,  67,  0,255,\n  191, 142,  0, 45,\n  255, 255,  0,  0]\n\narrayMutate(Analogous_1_gp,(v, i ,a) => v / 255);\n\n\nvar palettes = [black_Blue_Magenta_White_gp, es_landscape_33_gp, bhw1_05_gp, bhw1_04_gp, Sunset_Real_gp, Analogous_3_gp, Analogous_1_gp]\n\n// control variables for palette switch timing (these are in seconds)\nvar PALETTE_HOLD_TIME = 10\nvar PALETTE_TRANSITION_TIME = 3;\n\n// internal variables used by the palette manager.\n// Usually not necessary to change these.\nexport var currentIndex = 0;\nvar nextIndex = (currentIndex + 1) % palettes.length;\n\n// primarily useful for testing, go to the next palette in the main array. Skips the blend step. \nexport function triggerIncrementPalette(){\n  currentIndex = (currentIndex + 1) % palettes.length;\n}\n\n// arrays to hold rgb interpolation results\nvar pixel1 = array(3);\nvar pixel2 = array(3);\n\n// array to hold calculated blended palette\nvar PALETTE_SIZE = 16;\nvar currentPalette = array(4 * PALETTE_SIZE)\n\n// timing related variables\nvar inTransition = 0;\nvar blendValue = 0;\nrunTime = 0\n\n// Startup initialization for palette manager\nsetPalette(currentPalette);\nbuildBlendedPalette(palettes[currentIndex],palettes[nextIndex],blendValue)  \n\n// user space version of Pixelblaze's paint function. Stores\n// interpolated rgb color in rgbArray\nfunction paint2(v, rgbArray, pal) {\n  var k,u,l;\n  var rows = pal.length / 4;\n\n  // find the top bounding palette row\n  for (i = 0; i < rows;i++) {\n    k = pal[i * 4];\n    if (k >= v) break;\n  }\n\n  // fast path for special cases\n  if ((i == 0) || (i >= rows) || (k == v)) {\n    i = 4 * min(rows - 1, i);\n    rgbArray[0] = pal[i+1];\n    rgbArray[1] = pal[i+2];\n    rgbArray[2] = pal[i+3];    \n  }\n  else {\n    i = 4 * (i-1);\n    l = pal[i]   // lower bound    \n    u = pal[i+4]; // upper bound\n\n    pct = 1 -(u - v) / (u-l);\n    \n    rgbArray[0] = mix(pal[i+1],pal[i+5],pct);\n    rgbArray[1] = mix(pal[i+2],pal[i+6],pct);\n    rgbArray[2] = mix(pal[i+3],pal[i+7],pct);    \n  }\n}\n\n// utility function:\n// interpolate colors within and between two palettes\n// and set the LEDs directly with the result.  To be\n// used in render() functions\nfunction paletteMix(pal1, pal2, colorPct,palettePct) {\n  paint2(colorPct,pixel1,pal1);\n  paint2(colorPct,pixel2,pal2);  \n  \n  rgb(mix(pixel1[0],pixel2[0],palettePct),\n      mix(pixel1[1],pixel2[1],palettePct),\n      mix(pixel1[2],pixel2[2],palettePct)\n   )\n}\n\n// construct a new palette in the currentPalette array by blending \n// between pal1 and pal2 in proportion specified by blend\nfunction buildBlendedPalette(pal1, pal2, blend) {\n  var entry = 0;\n  \n  for (var i = 0; i < PALETTE_SIZE;i++) {\n    var v = i / PALETTE_SIZE;\n    \n    paint2(v,pixel1,pal1);\n    paint2(v,pixel2,pal2);  \n    \n    // build new palette at currrent blend level\n    currentPalette[entry++] = v;\n    currentPalette[entry++] = mix(pixel1[0],pixel2[0],blend)\n    currentPalette[entry++] = mix(pixel1[1],pixel2[1],blend)\n    currentPalette[entry++] = mix(pixel1[2],pixel2[2],blend)    \n  }\n}\n\nexport function beforeRender(delta) {\n  runTime = (runTime + delta / 1000) % 3600;\n\n  // Palette Manager - handle palette switching and blending with a \n  // tiny state machine  \n  if (inTransition) {\n    if (runTime >= PALETTE_TRANSITION_TIME) {\n      // at the end of a palette transition, switch to the \n      // next set of palettes and reset everything for the\n      // normal hold period.\n      runTime = 0;\n      inTransition = 0\n      blendValue = 0\n      currentIndex = (currentIndex + 1) % palettes.length\n      nextIndex = (nextIndex + 1) % palettes.length   \n\n    }\n    else {\n      // evaluate blend level during transition\n      blendValue = runTime / PALETTE_TRANSITION_TIME\n    }\n    \n    // blended palette is only recalculated during transition times. The rest of \n    // the time, we run with the current palette at full speed.\n    buildBlendedPalette(palettes[currentIndex],palettes[nextIndex],blendValue)          \n  }\n  else if (runTime >= PALETTE_HOLD_TIME) {\n    // when hold period ends, switch to palette transition\n    runTime = 0\n    inTransition = 1\n  }\n  \n  tf = 5 // Overall animation duration constant. A smaller duration runs faster.\n  \n  f  = wave(time(tf * 6.6 / 65.536)) * 5 + 2 // 2 to 7; Frequency (cell density)\n  t1 = wave(time(tf * 9.8 / 65.536)) * PI2  // 0 to 2*PI; Oscillates x shift\n  t2 = wave(time(tf * 12.5 / 65.536)) * PI2 // 0 to 2*PI; Oscillates y shift\n  t3 = wave(time(tf * 9.8 / 65.536)) // Shift h: wavelength of tf * 9.8 s\n  t4 = time(tf * 0.66 / 65.536) // Shift v: 0 to 1 every 0.66 sec\n  \n\n}\n\nexport function render2D(index, x, y) {\n  z = (1 + sin(x * f + t1) + cos(y * f + t2)) * .5 \n\n  /*\n    As explained in \"Matrix 2D Pulse\", z is now an egg-carton shaped surface\n    in x and y. The number of hills/valles visible (the frequency) is\n    proportional to f; f oscillates. The position of the centers in x and y \n    oscillate with t1 and t2. z's value ranges from -0.5 to 1.5.\n    \n    First, we'll derive the brightness (v) from this field.\n    \n    t4 is a 0 to 1 sawtooth, so (z + t4) now is between -0.5 and 2.5 wave(z +\n    t4) therefore cycles 0 to 1 three times, ever shifting (by t4) with respect\n    to the original egg carton.\n  */\n  v = wave(z + t4)\n  \n  // Typical concave-upward brightness scaling for perceptual aesthetics.\n  // v enters and exits as 0-1. 0 -> 0, 1 -> 1, but 0.5 -> 0.125 \n  v = v * v * v\n  \n  /*\n    Triangle will essentially double the frequency; t3 will add an \n    oscillating offset. With h in 0-1.5, hsv() \"wraps\" h, and since all\n    these functions are continuous, it's just spending extra time on the\n    hue wheel in the 0-0.5 range. Tweak this until you like how the final \n    colors progress over time, but anything based on z will make colors\n    related to the circles seen from above in the egg carton pattern.\n  */\n  h = triangle(z) / 2 + t3\n  \n  // original code does HSV. Using this instead of paint turns off all palettes.\n  //hsv(h, 1, v)\n  \n  paint(h,v)\n\n}\n\n/*\n  When there's no map defined, Pixelblaze will call render() instead of \n  render2D() or render3D(), so it's nice to define a graceful degradation for 1D\n  strips. For many geometric patterns, you'll want to define a projection down a\n  dimension. \n*/\nexport function render(index) {\n  pct = index / pixelCount  // Transform index..pixelCount to 0..1\n  // render2D(index, pct, pct)  // Render the diagonal of a matrix\n  // render2D(index, pct, 0)    // Render the top row of a matrix\n  render2D(index, 3 * pct, 0)   // Render 3 top rows worth to make it denser\n}\n\n// You can also project up a dimension. Think of this as mixing in the z value\n// to x and y in order to compose a stack of matrices.\nexport function render3D(index, x, y, z) {\n  x1 = (x - cos(z / 4 * PI2)) / 2\n  y1 = (y - sin(z / 4 * PI2)) / 2\n  render2D(index, x1, y1)\n}"
  },
  "preview": "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"
}