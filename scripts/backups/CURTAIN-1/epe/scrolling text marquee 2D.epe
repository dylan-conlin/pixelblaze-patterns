{
  "name": "scrolling text marquee 2D",
  "id": "yoPWeZprWxqcFEZqB",
  "sources": {
    "main": "/*\n  Scrolling text marquee 2D\n  \n  This pattern animates ASCII characters scrolling across an LED matrix.\n  \n    Demo: https://youtu.be/668eQjiqSRQ\n  \n  The default settings work well with the $14 8x8 matrix sold here:\n  \n    https://www.tindie.com/products/electromage/electromage-8x8-led-matrix/\n  \n  Use the mapper to define how the matrix is wired (for example, zig-zag). \n  The 8x8 grid above works with the default \"Matrix\" example on the Mapper tab.\n  \n  With no map and just a 1D strip, you can use this to light paint text:\n  \n    https://photos.app.goo.gl/vU2BQsP6V84Zr6Df7\n  \n  Author: Jeff Vyduna (https://ngnr.org)\n  Bugfixes: Zeb (https://forum.electromage.com/u/zeb)\n*/\n\n// Characters we want to scroll by every second. Try 3 for a matrix, or 30 for\n// persistence-of-vision on a strip.\nvar speed = 3\n\n// Define the message to be scrolled across the display\nvar messageLength = 10\nexport var message = array(messageLength) // Exported for setting via webSockets\n\n// \"  Hello?!?\"\nmessage[0] = 32; message[1] = 32;  // Leading spaces\nmessage[2] = 71;   // G\nmessage[3] = 97;  // a\nmessage[4] = 121;  // y \nmessage[5] = 63;  // ?\nmessage[6] = 63;  // ?\nmessage[7] = 63;  // ?\n\n\n/* \n  ASCII Chart\n\n  32      48 0    65 A   74 J    83 S    97  a    106 j    115 s\n  33 !    49 1    66 B   75 K    84 T    98  b    107 k    116 t\n  34 \"    50 2    67 C   76 L    85 U    99  c    108 l    117 u\n  35 #    51 3    68 D   77 M    86 V    100 d    109 m    118 v\n  36 $    52 4    69 E   78 N    87 W    101 e    110 n    119 w\n  37 %    53 5    70 F   79 O    88 X    102 f    111 o    120 x\n  38 &    54 6    71 G   80 P    89 Y    103 g    112 p    121 y\n  39 '    55 7    72 H   81 Q    90 Z    104 h    113 q    122 z\n  40 (    56 8    73 I   82 R            105 i    114 r    \n  41 )    57 9                                   \n  42 *    58 :                   91 [                      123 {\n  43 +    59 ;                   92 \\                      124 |\n  44 ,    60 <                   93 ]                      125 }\n  45 -    61 =                   94 ^                      126 ~\n  46 .    62 >                   95 _    \n  47 /    63 ?                   96 `                \n          64 @                                            \n*/\n\n\n// Define the font's character set bitmap. See \"Font Implementation\" below.\nvar charRows = 8 // Rows in a character. 1 array per row.\nvar charCols = 8 // Columns in a character. 1 bit per column.\n\nvar fontCharCount = 128 // Max characters in the font. Must be a multiple of 4.\nvar fontBitmap = array(charRows)\nfor (row = 0; row < charRows; row++) fontBitmap[row] = array(fontCharCount / 4)\n\n// Global 8x8bit array for storing and fetching characters from fontBitmap\nvar character = array(charRows)\n\n// Define the 2D matrix display. If your matrix is different dimentions, change\n// these to match or use a smaller matrixRows to scale your text height to fill.\nvar matrixRows = 8\nvar matrixCols = 8\nvar renderBuffer = array(matrixRows)\nfor (row = 0; row < matrixRows; row++) renderBuffer[row] = array(matrixCols)\n\nvar timer = 0 // Accumulates the ms between each beforeRender()\n\n// Calculate the ms between each left shift of the message across matrix columns\nvar colShiftPeriod = 1000 / speed / charCols\n\nexport function beforeRender(delta) {\n  timer += delta\n  if (timer > colShiftPeriod) { \n    timer -= colShiftPeriod\n    loadNextCol() // Shift and load a new column every colShiftPeriod ms\n  }\n}\n\nexport var hue, sat     // Exported so you can set them over websockets\nhue = 0.05; sat = 0.9   // warm white\n\nexport function render2D(index, x, y) {\n  // y is in world units of 0...1 where (0,0) is the top-left and y is +\u2193\n  row = floor(y * matrixRows)\n\n  // The column to render is like the row, but physical column 0 (the leftmost)\n  // starts bufferPointer columns into the renderBuffer.\n  col = (floor(x * matrixCols) + bufferPointer) % matrixCols\n  \n  v = renderBuffer[row][col]  // 1 or 0\n  hsv(hue, sat, v)\n}\n\n// On a strip, render the leftmost column. You can use this to light paint in\n// long exposure photographs, or render text in POV projects\nexport function render(index) {\n  // Flip such that pixel 0, usually the closest to power, is the bottom of text\n  index = pixelCount - index - 1\n  \n  // Mode 1: Use entire strip as a full character line height.\n  // row = floor(charRows * index/ pixelCount)\n  \n  // Mode 2: repeat the characters vertically, with linespacing\n  // If you flicker your eyes left-right, you can see the characters.\n  // Looks best if you set `speed` above to much faster, like 30 chars/sec\n  row = index % floor(1.5 * charRows) // 0.5em lineSpacing\n  if (row > charRows - 1) { hsv(0, 0, 0); return } // blank rows\n\n  // Render column 0, which starts bufferPointer columns into the renderBuffer\n  col = bufferPointer % matrixCols\n  \n  // The color is added for light painting rainbows, and so that it's still\n  // somewhat interesting on strips / the default sequencer\n  hue = wave(time(0.02)) - index / pixelCount\n  \n  hsv(hue, sat, renderBuffer[row][col])\n}\n\n\n// When we render the renderBuffer, we start by loading the leftmost column of\n// the matrix from the `bufferPointer` column in the renderBuffer.\nvar bufferPointer = 0 \n\n/*\n  E.g.: 8x8 matrix, rendering halfway through \"AC\": Right side of A, left of C\n\n          renderbuffer[r][c]             Renders as:\n\n  `bufferPointer` == 4 means leftmost column is here, and wraps around to 3\n                     \u2193       \n       col = 0 1 2 3 4 5 6 7                0 1 2 3 4 5 6 7\n    row = 0  . . . 1 1 . . .             0  1 . . . . . . 1  \n          1  . . 1 1 1 1 . .             1  1 1 . . . . 1 1  \n          2  . 1 1 . . 1 1 .             2  . 1 1 . . 1 1 .  \n          3  . 1 1 . . 1 1 .             3  . 1 1 . . 1 1 .  \n          4  . 1 1 . 1 1 1 .             4  1 1 1 . . 1 1 .  \n          4  . . 1 1 . 1 1 .             4  . 1 1 . . . 1 1  \n          5  . . . 1 . 1 1 .             5  . 1 1 . . . . 1  \n          7  . . . . . . . .             7  . . . . . . . .  \n                     \u2191\n                     This column will be replaced with the next column of \"C\",\n                       \u2191 then we'll advance `bufferPointer`\n                     \nEach element is a 16.16 fixed point number, so you could decide to pack HSV or \nRGB info into each byte, but this example is monochrome so each element just \nstores a 0 or 1, making rendering as simple as:\n\n    if (renderBuffer[row][col]) hsv(0,0,1)\n*/\n\nvar messageCols = messageLength * charCols // e.g., 12 chars have 96 columns\nvar messageColPointer = 0 // The next column of the overall message to load\n\n// Load the next column from `message` into `renderBuffer` at `bufferPointer`\nfunction loadNextCol() {\n  charIndex = message[floor(messageColPointer / charCols)]\n  fetchCharacter(charIndex) // loads global `character` with ASCII charIndex\n  \n  colIndex = messageColPointer % charCols\n  for (row = 0; row < charRows; row++) {\n    bit = (((character[row] << colIndex) & 0b10000000) == 0b10000000)\n    renderBuffer[row][bufferPointer] = bit\n  }\n  \n  bufferPointer = (bufferPointer + 1) % matrixCols\n  messageColPointer = (messageColPointer + 1) % messageCols\n}\n\n\n\n/*\n  Font Implementation\n  \n  Pixelblaze currently supports up to 64 arrays with 2048 array elements.\n  \n  To store a character set of 8x8 bit characters, we use 8 arrays, \n  one for each row.\n  \n  Four 8-bit maps are packed into each 32 bit array element. This makes the\n  bitwise code a little hard to follow, but uses memory efficiently. The 8 most\n  significant bits are referred to as \"bank 0\"; the next eight bits just left of\n  the binary point are \"bank 1\", etc.\n  \n  Here's the scheme used to store the font bitmap. A period is a zero.\n  \n    ASCII character  A        B        C        D        E\n        `charIndex`  65       66       67       68       69\n      array element  [16]     [16]     [16]     [16]     [17]\n               bank  0        1        2        3        0      \n      fontBitmap[0]  ..11.... 111111.. ..1111.. 11111... 1111111.\n      fontBitmap[1]  .1111... .11..11. .11..11. .11.11.. .11...1.\n      fontBitmap[2]  11..11.. .11..11. 11...... .11..11. .11.1...\n      fontBitmap[3]  11..11.. .11111.. 11...... .11..11. .1111...\n      fontBitmap[4]  111111.. .11..11. 11...... .11..11. .11.1...\n      fontBitmap[5]  11..11.. .11..11. .11..11. .11.11.. .11...1.\n      fontBitmap[6]  11..11.. 111111.. ..1111.. 11111... 1111111.\n      fontBitmap[7]  ........ ........ ........ ........ ........\n  \n  charIndex 0..31 (traditionally the ASCII control characters) are left \n  blank for user-defined custom characters.\n*/\n\n/*\n  Font and character functions\n\n  The storeCharacter functions take the character index (< `fontCharCount`) and \n  8 rows of 8 bits. Each row is a byte representing 8 bits of on/off bitmap data\n  to become the pixels of a character. Therefore, this implementation is \n  currently tightly coupled to 8-bit wide characters.\n*/\n\n/*\n  At character index `charIndex`, store 8 bytes of row data specified as \n  sequential arguments r0-r7. This allows us to easily use the public domain \n  font specified as comma-delimited hex bytes at:\n  \n  https://github.com/rene-d/fontino/blob/master/font8x8_ib8x8u.ino\n*/\nfunction storeCharacter(charIndex, r0, r1, r2, r3, r4, r5, r6, r7) {\n  element = floor(charIndex / 4)\n  bank = charIndex % 4\n  packByte(0, element, bank, r0)\n  packByte(1, element, bank, r1)\n  packByte(2, element, bank, r2)\n  packByte(3, element, bank, r3)\n  packByte(4, element, bank, r4)\n  packByte(5, element, bank, r5)\n  packByte(6, element, bank, r6)\n  packByte(7, element, bank, r7)\n}\n\n/*\n  This alternate style stores the character using the 8 row global array named \n  `character`. It could be useful for storing sprites after transformations to\n  create animations.\n*/\nfunction storeCharacter2(charIndex) {\n  element = floor(charIndex / 4)\n  bank = charIndex % 4\n  for (var row = 0; row < charRows; row++) {\n    packByte(row, element, bank, character[row])\n  }\n}\n\n// Loads the global `character` from the specified charIndex\nfunction fetchCharacter(charIndex) {\n  element = floor(charIndex / 4)\n  bank = charIndex % 4\n  for (var row = 0; row < charRows; row++) {\n    character[row] = unpackByte(row, element, bank)\n  }\n}\n\n/*\n  For a given row of a font's pixel data (fontBitmap[row]), there's a \n  (fontCharCount / 4) element long array that holds 32 bits per array element. \n  Thinking of each array element as a 4-byte word, the \"bank\" (0..3) specifies \n  which set of 8 bits we're storing for a particular character. Characters are \n  referred to by their charIndex (ASCII number), so:\n  bank 0 in elements 0, 1, & 2 store the data for characters 0, 4, 8, etc;\n  Bank 1 in elements 0, 1, & 2 store the data for characters 1, 5, 9, etc.\n  \n  The method below is used because the bitwise operators only work on \n  the top 16 bits.\n*/\nvar byteHolder = array(4)\nfunction packByte(row, element, bank, byte) {\n  original = fontBitmap[row][element]\n  \n  // Load a 4-element array with the individual bytes in this 32 bit 'word'\n  for (_bank = 0; _bank < 4; _bank++) {\n    byteHolder[_bank] = (((original << (_bank * 8)) & 0xFF00) >> 8) & 0xFF\n  }\n  \n  // Override the 8 bits we're trying to store\n  byteHolder[bank] = byte \n  \n  // Reassemble the 32 bit 'word'\n  fontBitmap[row][element] = (byteHolder[0] << 8) \n                            + byteHolder[1] \n                           + (byteHolder[2] >> 8) \n                           + (byteHolder[3] >> 16)\n}\n\n// Inverse of packByte()\nfunction unpackByte(row, element, bank) {\n  word = fontBitmap[row][element]\n  if (bank > 1) {\n    byte = word << (8 * (bank - 1))\n  } else if (bank == 0) {\n    byte = word >> 8\n  } else {\n    byte = word\n  }\n  return byte & 0xFF // Zero out all but the 8 bits left of the binary point\n}\n\n\n\n/* \n  Font Data\n\n  Public domain, courtesy of\n  https://github.com/rene-d/fontino/blob/master/font8x8_ib8x8u.ino\n*/\n\nstoreCharacter( 32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)  // 0x20 (space)\nstoreCharacter( 33, 0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00)  // 0x21 (exclam)\nstoreCharacter( 34, 0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00)  // 0x22 (quotedbl)\nstoreCharacter( 35, 0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00)  // 0x23 (numbersign)\nstoreCharacter( 36, 0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00)  // 0x24 (dollar)\nstoreCharacter( 37, 0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00)  // 0x25 (percent)\nstoreCharacter( 38, 0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00)  // 0x26 (ampersand)\nstoreCharacter( 39, 0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00)  // 0x27 (quotesingle)\nstoreCharacter( 40, 0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00)  // 0x28 (parenleft)\nstoreCharacter( 41, 0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00)  // 0x29 (parenright)\nstoreCharacter( 42, 0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00)  // 0x2a (asterisk)\nstoreCharacter( 43, 0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00)  // 0x2b (plus)\nstoreCharacter( 44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60)  // 0x2c (comma)\nstoreCharacter( 45, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00)  // 0x2d (hyphen)\nstoreCharacter( 46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00)  // 0x2e (period)\nstoreCharacter( 47, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00)  // 0x2f (slash)\nstoreCharacter( 48, 0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00)  // 0x30 (zero)\nstoreCharacter( 49, 0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00)  // 0x31 (one)\nstoreCharacter( 50, 0x78, 0xcc, 0x0c, 0x38, 0x60, 0xc4, 0xfc, 0x00)  // 0x32 (two)\nstoreCharacter( 51, 0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00)  // 0x33 (three)\nstoreCharacter( 52, 0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00)  // 0x34 (four)\nstoreCharacter( 53, 0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00)  // 0x35 (five)\nstoreCharacter( 54, 0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00)  // 0x36 (six)\nstoreCharacter( 55, 0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00)  // 0x37 (seven)\nstoreCharacter( 56, 0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00)  // 0x38 (eight)\nstoreCharacter( 57, 0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00)  // 0x39 (nine)\nstoreCharacter( 58, 0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00)  // 0x3a (colon)\nstoreCharacter( 59, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x60, 0x00)  // 0x3b (semicolon)\nstoreCharacter( 60, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00)  // 0x3c (less)\nstoreCharacter( 61, 0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00)  // 0x3d (equal)\nstoreCharacter( 62, 0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00)  // 0x3e (greater)\nstoreCharacter( 63, 0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00)  // 0x3f (question)\nstoreCharacter( 64, 0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00)  // 0x40 (at)\nstoreCharacter( 65, 0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00)  // 0x41 (A)\nstoreCharacter( 66, 0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00)  // 0x42 (B)\nstoreCharacter( 67, 0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00)  // 0x43 (C)\nstoreCharacter( 68, 0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00)  // 0x44 (D)\nstoreCharacter( 69, 0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00)  // 0x45 (E)\nstoreCharacter( 70, 0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00)  // 0x46 (F)\nstoreCharacter( 71, 0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00)  // 0x47 (G)\nstoreCharacter( 72, 0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00)  // 0x48 (H)\nstoreCharacter( 73, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00)  // 0x49 (I)\nstoreCharacter( 74, 0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00)  // 0x4a (J)\nstoreCharacter( 75, 0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00)  // 0x4b (K)\nstoreCharacter( 76, 0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00)  // 0x4c (L)\nstoreCharacter( 77, 0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00)  // 0x4d (M)\nstoreCharacter( 78, 0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00)  // 0x4e (N)\nstoreCharacter( 79, 0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00)  // 0x4f (O)\nstoreCharacter( 80, 0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00)  // 0x50 (P)\nstoreCharacter( 81, 0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00)  // 0x51 (Q)\nstoreCharacter( 82, 0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00)  // 0x52 (R)\nstoreCharacter( 83, 0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00)  // 0x53 (S)\nstoreCharacter( 84, 0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00)  // 0x54 (T)\nstoreCharacter( 85, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00)  // 0x55 (U)\nstoreCharacter( 86, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00)  // 0x56 (V)\nstoreCharacter( 87, 0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00)  // 0x57 (W)\nstoreCharacter( 88, 0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00)  // 0x58 (X)\nstoreCharacter( 89, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00)  // 0x59 (Y)\nstoreCharacter( 90, 0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00)  // 0x5a (Z)\nstoreCharacter( 91, 0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00)  // 0x5b (bracketleft)\nstoreCharacter( 92, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00)  // 0x5c (backslash)\nstoreCharacter( 93, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00)  // 0x5d (bracketright)\nstoreCharacter( 94, 0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00)  // 0x5e (asciicircum)\nstoreCharacter( 95, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff)  // 0x5f (underscore)\nstoreCharacter( 96, 0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00)  // 0x60 (grave)\nstoreCharacter( 97, 0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00)  // 0x61 (a)\nstoreCharacter( 98, 0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00)  // 0x62 (b)\nstoreCharacter( 99, 0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00)  // 0x63 (c)\nstoreCharacter(100, 0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00)  // 0x64 (d)\nstoreCharacter(101, 0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00)  // 0x65 (e)\nstoreCharacter(102, 0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00)  // 0x66 (f)\nstoreCharacter(103, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8)  // 0x67 (g)\nstoreCharacter(104, 0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00)  // 0x68 (h)\nstoreCharacter(105, 0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00)  // 0x69 (i)\nstoreCharacter(106, 0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78)  // 0x6a (j)\nstoreCharacter(107, 0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00)  // 0x6b (k)\nstoreCharacter(108, 0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00)  // 0x6c (l)\nstoreCharacter(109, 0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00)  // 0x6d (m)\nstoreCharacter(110, 0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00)  // 0x6e (n)\nstoreCharacter(111, 0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00)  // 0x6f (o)\nstoreCharacter(112, 0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0)  // 0x70 (p)\nstoreCharacter(113, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e)  // 0x71 (q)\nstoreCharacter(114, 0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00)  // 0x72 (r)\nstoreCharacter(115, 0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00)  // 0x73 (s)\nstoreCharacter(116, 0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00)  // 0x74 (t)\nstoreCharacter(117, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00)  // 0x75 (u)\nstoreCharacter(118, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00)  // 0x76 (v)\nstoreCharacter(119, 0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00)  // 0x77 (w)\nstoreCharacter(120, 0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00)  // 0x78 (x)\nstoreCharacter(121, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8)  // 0x79 (y)\nstoreCharacter(122, 0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00)  // 0x7a (z)\nstoreCharacter(123, 0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00)  // 0x7b (braceleft)\nstoreCharacter(124, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00)  // 0x7c (bar)\nstoreCharacter(125, 0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00)  // 0x7d (braceright)\nstoreCharacter(126, 0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)  // 0x7e (asciitilde)\n\n\n// Other user-defined custom characters\n\n// ASCII 63 is the question mark - here's an alternative from the \n// Sinclair ZX81 font, stored in custom slot 30\nstoreCharacter(30,\n  0b00000000,\n  0b00111100,\n  0b01000010,\n  0b00000100,\n  0b00001000,\n  0b00000000,\n  0b00001000,\n  0b00000000\n)\n\n// This demonstrates copying the character, altering it, then storing it in the \n// next slot. You could use this for programmatic animation.\nfetchCharacter(30)\ncharacter[7] = 0b00001000\nstoreCharacter2(31)\n"
  },
  "preview": "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"
}