{
  "name": "spotlights rotation 3D",
  "id": "Fvhhj7uo6xaDciS46",
  "sources": {
    "main": "/*\n  Spotlights / rotation 3D\n  \n  This pattern demonstrates one way to rotationally transform 3D space, which\n  results in the impression we're rotating whatever pattern was generated.\n  \n  3D example: https://youtu.be/uoAJg5J6F1Q\n  \n  This pattern assumes a 3D installation that's been mapped in the Mapper tab,\n  but degrades to somewhat less interesting projections in 2D and 1D. \n*/\n\n\nscale = 1 / (PI * PI) // How wide the \"spotlights\" are\nspeed = 0.1            // How fast they rotate around\n\nexport function beforeRender(delta) {\n  // We could just use sin(time()) to output -1..1, but that's almost too smooth\n  t1 = 2 * triangle(time(.03 / speed)) - 1\n  t2 = 2 * triangle(time(.04 / speed)) - 1\n  t3 = 2 * triangle(time(.05 / speed)) - 1\n  t4 = time(.02 / speed)\n  \n  // The axis we'll rotate around is a vector (t1, t2, t3) - each -1..1.\n  // The angle to rotate about it is a 0..2*PI sawtooth.\n  setupRotationMatrix(t1, t2, t3, t4 * PI2)\n}\n\nexport function render3D(index, _x, _y, _z) {\n  // Shift (0, 0, 0) to be the center of the world, not the rear-top-left\n  x = _x - 0.5; y = _y - 0.5; z = _z - 0.5\n  \n  /*\n    In beforeRender(), setupRotationMatrix() calculated a rotation matrix for\n    this frame. rotate3D() now applies it to the current pixel's [shifted]\n    position. As seen below, this sets rotated global variables rx, ry, and rz.\n    You could also return an array of [rx, ry, rz], but that adds one slightly\n    slower step to an already computationally-intense pattern.\n  */\n  rotate3D(x, y, z)\n  \n  /*\n    `dist` is the distance (in world units) from a cone's surface to this \n    pixel. Positive values are inside the cone. If you try a different scale\n    for x vs y, you'll see elliptical cones.\n  */\n  dist = abs(rz) - sqrt(rx * rx / scale + ry * ry / scale)\n\n  dist = clamp(dist, -1, 1) // Try commenting this out.. Whoa!\n  \n  //  magenta,  white center,  sub-pixel rendered border\n  hsv(0.97,     1-dist,        pow((1 + dist), 4))\n}\n\n// A planar slice of this pattern will look like a projection surface that\n// someone's waving a flashlight at.\nexport function render2D(index, x, y) {\n  render3D(index, x, y, 0)\n}\n\n// In 1D it's a frenetic swooping region\nexport function render(index) {\n  render3D(index, index / pixelCount * 2, 0, 0)\n}\n  \n\n\n/*\n  setupRotationMatrix()\n  Takes a vector (ux, uy, uz) which will be the axis to rotate around,\n    and an angle in radians.\n  Computes a 3D rotation matrix and stores it in a global named R\n  \n  https://en.wikipedia.org/wiki/Rotation_matrix\n*/\n\nvar R = array(3); for (i=0; i<3; i++) R[i] = array(3)  // init 3x3, R[r][c]\n\nfunction setupRotationMatrix(ux, uy, uz, angle) {\n  // Rescale ux, uy, uz to make sure it's a unit vector, length = 1\n  length = sqrt(ux * ux + uy * uy + uz * uz)\n  ux /= length; uy /=length; uz /= length\n  \n  // Precompute a few reused values\n  cosa = cos(angle); sina = sin(angle)\n  ccosa = 1 - cosa\n  xyccosa = ux * uy * ccosa\n  xzccosa = ux * uz * ccosa\n  yzccosa = uy * uz * ccosa\n  xsina = ux * sina; ysina = uy * sina; zsina = uz * sina\n  \n  R[0][0] = cosa + ux * ux * ccosa\n  R[0][1] = xyccosa - zsina\n  R[0][2] = xzccosa + ysina\n  R[1][0] = xyccosa + zsina\n  R[1][1] = cosa + uy * uy * ccosa\n  R[1][2] = yzccosa - xsina\n  R[2][0] = xzccosa - ysina\n  R[2][1] = yzccosa + xsina\n  R[2][2] = cosa + uz * uz * ccosa\n}\n\n/*\n  rotate3D()\n  Takes 3 coordinates (x, y, z) and expects R to be a global rotation matrix.\n  Sets globals rx, ry, and rz as the rotated point's new coordinates.\n  (Globals are used for speed and convenience in the Pixelblaze lang)\n*/\nvar rx, ry, rz\nfunction rotate3D(x, y, z) {\n  rx = R[0][0] * x + R[0][1] * y + R[0][2] * z\n  ry = R[1][0] * x + R[1][1] * y + R[1][2] * z\n  rz = R[2][0] * x + R[2][1] * y + R[2][2] * z\n}\n"
  },
  "preview": "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"
}