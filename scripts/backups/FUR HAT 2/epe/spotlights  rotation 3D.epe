{
  "name": "spotlights  rotation 3D",
  "id": "Fvhhj7uo6xaDciS46",
  "sources": {
    "main": "/*\n  Spotlights / rotation 3D\n  \n  This pattern demonstrates one way to rotationally transform 3D space, which\n  results in the impression we're rotating whatever pattern was generated.\n  \n  3D example: https://youtu.be/uoAJg5J6F1Q\n  \n  This pattern assumes a 3D installation that's been mapped in the Mapper tab,\n  but degrades to somewhat less interesting projections in 2D and 1D. \n*/\n\n\nscale = 1 / (PI * PI) // How wide the \"spotlights\" are\nspeed = 0.1            // How fast they rotate around\n\nexport function beforeRender(delta) {\n  // We could just use sin(time()) to output -1..1, but that's almost too smooth\n  t1 = 2 * triangle(time(.03 / speed)) - 1\n  t2 = 2 * triangle(time(.04 / speed)) - 1\n  t3 = 2 * triangle(time(.05 / speed)) - 1\n  t4 = time(.02 / speed)\n  \n  // The axis we'll rotate around is a vector (t1, t2, t3) - each -1..1.\n  // The angle to rotate about it is a 0..2*PI sawtooth.\n  setupRotationMatrix(t1, t2, t3, t4 * PI2)\n}\n\nexport function render3D(index, _x, _y, _z) {\n  // Shift (0, 0, 0) to be the center of the world, not the rear-top-left\n  x = _x - 0.5; y = _y - 0.5; z = _z - 0.5\n  \n  /*\n    In beforeRender(), setupRotationMatrix() calculated a rotation matrix for\n    this frame. rotate3D() now applies it to the current pixel's [shifted]\n    position. As seen below, this sets rotated global variables rx, ry, and rz.\n    You could also return an array of [rx, ry, rz], but that adds one slightly\n    slower step to an already computationally-intense pattern.\n  */\n  rotate3D(x, y, z)\n  \n  /*\n    `dist` is the distance (in world units) from a cone's surface to this \n    pixel. Positive values are inside the cone. If you try a different scale\n    for x vs y, you'll see elliptical cones.\n  */\n  dist = abs(rz) - sqrt(rx * rx / scale + ry * ry / scale)\n\n  dist = clamp(dist, -1, 1) // Try commenting this out.. Whoa!\n  \n  //  magenta,  white center,  sub-pixel rendered border\n  hsv(0.97,     1-dist,        pow((1 + dist), 4))\n}\n\n// A planar slice of this pattern will look like a projection surface that\n// someone's waving a flashlight at.\nexport function render2D(index, x, y) {\n  render3D(index, x, y, 0)\n}\n\n// In 1D it's a frenetic swooping region\nexport function render(index) {\n  render3D(index, index / pixelCount * 2, 0, 0)\n}\n  \n\n\n/*\n  setupRotationMatrix()\n  Takes a vector (ux, uy, uz) which will be the axis to rotate around,\n    and an angle in radians.\n  Computes a 3D rotation matrix and stores it in a global named R\n  \n  https://en.wikipedia.org/wiki/Rotation_matrix\n*/\n\nvar R = array(3); for (i=0; i<3; i++) R[i] = array(3)  // init 3x3, R[r][c]\n\nfunction setupRotationMatrix(ux, uy, uz, angle) {\n  // Rescale ux, uy, uz to make sure it's a unit vector, length = 1\n  length = sqrt(ux * ux + uy * uy + uz * uz)\n  ux /= length; uy /=length; uz /= length\n  \n  // Precompute a few reused values\n  cosa = cos(angle); sina = sin(angle)\n  ccosa = 1 - cosa\n  xyccosa = ux * uy * ccosa\n  xzccosa = ux * uz * ccosa\n  yzccosa = uy * uz * ccosa\n  xsina = ux * sina; ysina = uy * sina; zsina = uz * sina\n  \n  R[0][0] = cosa + ux * ux * ccosa\n  R[0][1] = xyccosa - zsina\n  R[0][2] = xzccosa + ysina\n  R[1][0] = xyccosa + zsina\n  R[1][1] = cosa + uy * uy * ccosa\n  R[1][2] = yzccosa - xsina\n  R[2][0] = xzccosa - ysina\n  R[2][1] = yzccosa + xsina\n  R[2][2] = cosa + uz * uz * ccosa\n}\n\n/*\n  rotate3D()\n  Takes 3 coordinates (x, y, z) and expects R to be a global rotation matrix.\n  Sets globals rx, ry, and rz as the rotated point's new coordinates.\n  (Globals are used for speed and convenience in the Pixelblaze lang)\n*/\nvar rx, ry, rz\nfunction rotate3D(x, y, z) {\n  rx = R[0][0] * x + R[0][1] * y + R[0][2] * z\n  ry = R[1][0] * x + R[1][1] * y + R[1][2] * z\n  rz = R[2][0] * x + R[2][1] * y + R[2][2] * z\n}\n"
  },
  "preview": "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"
}