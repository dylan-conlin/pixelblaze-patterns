{
  "name": "Animated Asterisks 2D",
  "id": "ho8SPPmQLxh8qu7x9",
  "sources": {
    "main": "///////////////////////////////////////////////////\n//\n//  Matrix configuration\n//\nvar matrixWidth = sqrt(pixelCount);\n\n\n///////////////////////////////////////////////////\n//\n//  UI settings\n//\n\n//  The number of lines in the asterisk.\nvar maxLines = 50;\nexport var numLines = 6; \n// If you are using the WS2812B LED type and are getting garbage in the first row for numLines > 2 or 3, \n// it's probably because the line distance function is too heavy to calculate inside the render() function.\n// With the LED type set to \"double-buffered WS2812B\" it works fine up to 50 or 60 lines (!).\nexport function sliderNumLines(v) { numLines = 1 + floor((maxLines - 1) * v); }\n\n//  The width of the lines.\nexport var lineWidth = 0.1 / matrixWidth;\n// A LineWidth less than 0.25 or so gives some very interesting particle effects; a lineWidth greater than 1\n// starts to occupy the entire matrix and gives a different effect.  \nexport function sliderLineWidth(v) { lineWidth = newLineWidth(v); }\nfunction newLineWidth(v) { return (0.01 + (matrixWidth / numLines) * v) / matrixWidth; }\n\n//  When set, varies the lineWidth over the course of several seconds to show different effects.\nexport var animateWidth = 1;\nexport function sliderAnimateWidth(v) { animateWidth = 1 - floor(1 - v); }\n\n//  The speed of rotation\nexport var rotationSpeed = 0.031;\nexport function sliderRotationSpeed(v) { rotationSpeed = 0.005 + .045 * (1-v)*(1-v); }\n\n//  The speed of color change\nexport var colorSpeed = 0.2;\nexport function sliderColorSpeed(v) { colorSpeed = 0.01 + .39 * (1-v)*(1-v); }\n\n///////////////////////////////////////////////////\n//\n//  Pattern storage\n//\nvar xBegin = array(maxLines);\nvar yBegin = array(maxLines);\nvar xEnd = array(maxLines);\nvar yEnd = array(maxLines);\nvar lineHue = array(maxLines);\n\n\n///////////////////////////////////////////////////\n//\n//  Render functions\n//\nvar centerX = 0.5;\nvar centerY = 0.5;\nexport function beforeRender(delta) {\n  newAngle = time(rotationSpeed) * PI2;\n  newColor = time(colorSpeed);\n  if (animateWidth > 0) lineWidth = newLineWidth(triangle(time(1)));\n  for (line=0;line<numLines;line++) {\n    //  Change the color.\n    lineHue[line] = (newColor + (line / numLines)) % 1;\n    //  calculate new position.\n    thisAngle = newAngle + PI * line / numLines;\n    horizontal = cos(thisAngle) / 2;\n    vertical = sin(thisAngle) / 2;\n    xBegin[line] = centerX + horizontal;\n    xEnd[line] = centerX - horizontal;\n    yBegin[line] = centerY + vertical;\n    yEnd[line] = centerY - vertical;\n  }\n}\n\n\nfunction pointDistanceFromLine(Px, Py, Ax, Ay, Bx, By) {\n  // vector AB\n  ABx = Bx - Ax; ABy = By - Ay;\n  // vector BP\n  BPx = Px - Bx; BPy = Py - By;\n  // vector AP\n  APx = Px - Ax; APy = Py - Ay;\n\n  // There are three possibilities:\n  if ((ABx * APx + ABy * APy) < 0) {    // outside the near endpoint => negative dot product\n    return sqrt(APx * APx + APy * APy);\n  }\n  else if ((ABx * BPx + ABy * BPy) > 0) {    // outside the far endpoint => positive dot product\n    return sqrt(BPx * BPx + BPy * BPy);\n  }\n  else {\n    // We're somewhere in the middle\n    return abs(ABx * APy - ABy * APx) / sqrt(ABx * ABx + ABy * ABy);\n  }\n}\n\n\nexport function render2D(index, xPoint, yPoint) {\n  for (line=0;line<numLines;line++) {\n    distance = pointDistanceFromLine(xPoint, yPoint, xBegin[line], yBegin[line], xEnd[line], yEnd[line]);\n    if (distance < lineWidth) { \n      hsv(lineHue[line], 1, 1 - distance / lineWidth); \n      return; \n    }\n  }\n  hsv(0, 0, 0);\n}\n"
  },
  "preview": "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"
}