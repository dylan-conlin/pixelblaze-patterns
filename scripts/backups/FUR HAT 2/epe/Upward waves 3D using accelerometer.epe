{
  "name": "Upward waves 3D using accelerometer",
  "id": "TjjFM8f8BauymMxqz",
  "sources": {
    "main": "/*\nThis pattern is largely inspired (and borrows from) GlowFlow:\nhttps://hackaday.io/project/166871-glow-flow\nhttps://newscrewdriver.com/tag/glow-flow/\nhttps://github.com/Roger-random/glowflow\n\nThe accelerometer is used to determine which way is \"up\" and\ncorresponding coordinate transformations are applied to keep\nthe animation oriented.\n\nA simple IIR averaging filter is used to smooth out \naccelerometer samples.\n\nAdditionally, the coordinates can be rotated to put a mapped \ncube on it's corner to match the build of the Pixelblaze cube\nstand.\n\n10/8/2021 - Ben Hencke\n\n*/\n\nexport var accelerometer\n\n//larger filterFactor values are smoother but slower to respond\nvar filterFactor = .7 \nvar rotateForPBCube = false\n\n\n// Polar angle is how far the vector is tilted, relative to +Z axis. (On a globe, it is latitude.)\n// 0 = vector is pointing up, aligned with +Z\n// PI = vector is pointing down, aligned with -Z\nfunction polarAngle(x,y,z) {\n  polar = 0\n\n  if (z == 0) {\n    // Z = 0 means vector is somewhere on XY plane.\n    // Hard code answer is faster and avoids divide by zero.\n    polar = PI/2\n  } else if (z > 0) {\n    // +Z = between 0 and PI/2\n    polar = atan(sqrt(pow(x,2)+pow(y,2))/z)\n  } else {\n    // -Z = between PI/2 and PI\n    polar = PI-atan(sqrt(pow(x,2)+pow(y,2))/-z)\n  }\n\n  return polar\n}\n\n// Azimuth is direction of polar angle projected on XY plane. (On a globe, it is longitude.)\n// 0 = vector is aligned with +X\n// PI/2 = vector is aligned with +Y\n// -PI/2 = vector is aligned with -Y\nfunction azimuthAngle(x,y) {\n  azimuth = 0\n\n  if (x == 0) {\n    // X of zero means vector is aligned with Y axis one way or another.\n    // Hard code answer is faster and avoids divide by zero\n    if (y >= 0) {\n      // Aligned with +Y axis\n      azimuth = PI/2\n    } else {\n      // Aligned with -Y axis\n      azimuth = -PI/2\n    }\n  } else if (x > 0) {\n    // +X = somewhere between -PI/2 and PI/2\n    azimuth = atan(y/x)\n  } else {\n    // -X = somewhere between PI and PI/2 for +Y, between -PI and -PI/2 for -Y\n    azimuth = PI-atan(y/-x)\n  }\n\n  return azimuth\n}\n\n\nexport var aa, pa //azimuth angle and polar angle for the animation frame\nexport var x, y, z, gForce\n\nexport function beforeRender(delta) {\n  t2 = time(2.1)\n  \n  //apply an averaging filter to the accelerometer readings\n  //also, for my build I'm swapping around the x and y axis\n  //and swapping which way is up or forward by negating the \n  //accelerometer sample\n  x = (x * filterFactor) + (accelerometer[1] * (1-filterFactor))\n  y = (y * filterFactor) + (-accelerometer[0] * (1-filterFactor))\n  z = (z * filterFactor) + (-accelerometer[2] * (1-filterFactor))\n  \n  aa = azimuthAngle(x, z) - PI/2\n  pa = polarAngle(x, z, y) - PI/2\n\n  //accelerometer samples are right about 1/50th of a G\n  gForce = hypot3(x, y, z) * 50 \n  \n  resetTransform()\n  translate3D(-.5, -.5, -.5)\n  \n  //re-orient the cube to stand on it's corner\n  if (rotateForPBCube) {\n    rotateZ(PI*.25)\n    rotateX(PI*.3)\n  }\n  \n  //apply rotations based on accelerometer\n  rotateY(aa)\n  rotateX(-pa)\n}\n\n\nexport function render3D(index, x, y, z) {\n  //base the color on the distance from center\n  h = hypot(x,y) * 1.5 + .5\n  //make bands of light travel upwards along the z axis by shifting a \n  //triangle waveform down, then multipling it so that the\n  //positive peak reaches 1, then scale by g forces.\n  v = (triangle(z - t2) - .5) * 2 * gForce\n  v = max(v, 0) //clip negative to zero\n  v = v*v*v*v  //sharpen the band a bit\n  hsv(h, 1, v)\n}\n\n/*\nThis pattern is largely inspired (and borrows from) GlowFlow:\nhttps://hackaday.io/project/166871-glow-flow\nhttps://newscrewdriver.com/tag/glow-flow/\nhttps://github.com/Roger-random/glowflow\n\nThe accelerometer is used to determine which way is \"up\" and\ncorresponding coordinate transformations are applied to keep\nthe animation oriented.\n\nA simple IIR averaging filter is used to smooth out \naccelerometer samples.\n\nAdditionally, the coordinates can be rotated to put a mapped \ncube on it's corner to match the build of the Pixelblaze cube\nstand.\n\n10/8/2021 - Ben Hencke\n\n*/\n\nexport var accelerometer\n\n//larger filterFactor values are smoother but slower to respond\nvar filterFactor = .99\nvar rotateForPBCube = false\n\n\n// Polar angle is how far the vector is tilted, relative to +Z axis. (On a globe, it is latitude.)\n// 0 = vector is pointing up, aligned with +Z\n// PI = vector is pointing down, aligned with -Z\nfunction polarAngle(x,y,z) {\n  polar = 0\n\n  if (z == 0) {\n    // Z = 0 means vector is somewhere on XY plane.\n    // Hard code answer is faster and avoids divide by zero.\n    polar = PI/2\n  } else if (z > 0) {\n    // +Z = between 0 and PI/2\n    polar = atan(sqrt(pow(x,2)+pow(y,2))/z)\n  } else {\n    // -Z = between PI/2 and PI\n    polar = PI-atan(sqrt(pow(x,2)+pow(y,2))/-z)\n  }\n\n  return polar\n}\n\n// Azimuth is direction of polar angle projected on XY plane. (On a globe, it is longitude.)\n// 0 = vector is aligned with +X\n// PI/2 = vector is aligned with +Y\n// -PI/2 = vector is aligned with -Y\nfunction azimuthAngle(x,y) {\n  azimuth = 0\n\n  if (x == 0) {\n    // X of zero means vector is aligned with Y axis one way or another.\n    // Hard code answer is faster and avoids divide by zero\n    if (y >= 0) {\n      // Aligned with +Y axis\n      azimuth = PI/2\n    } else {\n      // Aligned with -Y axis\n      azimuth = -PI/2\n    }\n  } else if (x > 0) {\n    // +X = somewhere between -PI/2 and PI/2\n    azimuth = atan(y/x)\n  } else {\n    // -X = somewhere between PI and PI/2 for +Y, between -PI and -PI/2 for -Y\n    azimuth = PI-atan(y/-x)\n  }\n\n  return azimuth\n}\n\n\nexport var aa, pa //azimuth angle and polar angle for the animation frame\nexport var x, y, z, gForce\n\nexport function beforeRender(delta) {\n  t2 = time(10)\n  \n  //apply an averaging filter to the accelerometer readings\n  //also, for my build I'm swapping around the x and y axis\n  //and swapping which way is up or forward by negating the \n  //accelerometer sample\n  x = (x * filterFactor) + (accelerometer[1] * (1-filterFactor))\n  y = (y * filterFactor) + (-accelerometer[0] * (1-filterFactor))\n  z = (z * filterFactor) + (-accelerometer[2] * (1-filterFactor))\n  \n  aa = azimuthAngle(x, z) - PI/2\n  pa = polarAngle(x, z, y) - PI/2\n\n  //accelerometer samples are right about 1/50th of a G\n  gForce = hypot3(x, y, z) * 50 \n  \n  resetTransform()\n  translate3D(-.5, -.5, -.5)\n  \n  //re-orient the cube to stand on it's corner\n  if (rotateForPBCube) {\n    rotateZ(PI*.25)\n    rotateX(PI*.3)\n  }\n  \n  //apply rotations based on accelerometer\n  rotateY(aa)\n  rotateX(-pa)\n}\n\n\nexport function render3D(index, x, y, z) {\n  //base the color on the distance from center\n  h = hypot(x,y) * 1.5 + .5\n  //make bands of light travel upwards along the z axis by shifting a \n  //triangle waveform down, then multipling it so that the\n  //positive peak reaches 1, then scale by g forces.\n  v = (triangle(z - t2) - .5) * 2 * gForce\n  v = max(v, 0) //clip negative to zero\n  v = v*v*v*v  //sharpen the band a bit\n  hsv(h, 1, v)\n}\n"
  },
  "preview": "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"
}