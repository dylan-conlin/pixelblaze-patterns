{
  "name": "spotlights rotation 3D",
  "id": "Fvhhj7uo6xaDciS46",
  "sources": {
    "main": "/*\n  Spotlights / rotation 3D\n  \n  This pattern demonstrates one way to rotationally transform 3D space, which\n  results in the impression we're rotating whatever pattern was generated.\n  \n  3D example: https://youtu.be/uoAJg5J6F1Q\n  \n  This pattern assumes a 3D installation that's been mapped in the Mapper tab,\n  but degrades to somewhat less interesting projections in 2D and 1D. \n*/\n\n\nscale = 1 / (PI * PI) // How wide the \"spotlights\" are\nspeed = 1             // How fast they rotate around\n\nexport function beforeRender(delta) {\n  // We could just use sin(time()) to output -1..1, but that's almost too smooth\n  t1 = 2 * triangle(time(.03 / speed)) - 1\n  t2 = 2 * triangle(time(.04 / speed)) - 1\n  t3 = 2 * triangle(time(.05 / speed)) - 1\n  t4 = time(.02 / speed)\n  \n  // The axis we'll rotate around is a vector (t1, t2, t3) - each -1..1.\n  // The angle to rotate about it is a 0..2*PI sawtooth.\n  setupRotationMatrix(t1, t2, t3, t4 * PI2)\n}\n\nexport function render3D(index, _x, _y, _z) {\n  // Shift (0, 0, 0) to be the center of the world, not the rear-top-left\n  x = _x - 0.5; y = _y - 0.5; z = _z - 0.5\n  \n  /*\n    In beforeRender(), setupRotationMatrix() calculated a rotation matrix for\n    this frame. rotate3D() now applies it to the current pixel's [shifted]\n    position. As seen below, this sets rotated global variables rx, ry, and rz.\n    You could also return an array of [rx, ry, rz], but that adds one slightly\n    slower step to an already computationally-intense pattern.\n  */\n  rotate3D(x, y, z)\n  \n  /*\n    `dist` is the distance (in world units) from a cone's surface to this \n    pixel. Positive values are inside the cone. If you try a different scale\n    for x vs y, you'll see elliptical cones.\n  */\n  dist = abs(rz) - sqrt(rx * rx / scale + ry * ry / scale)\n\n  dist = clamp(dist, -1, 1) // Try commenting this out.. Whoa!\n  \n  //  magenta,  white center,  sub-pixel rendered border\n  hsv(0.97,     1-dist,        pow((1 + dist), 4))\n}\n\n// A planar slice of this pattern will look like a projection surface that\n// someone's waving a flashlight at.\nexport function render2D(index, x, y) {\n  render3D(index, x, y, 0)\n}\n\n// In 1D it's a frenetic swooping region\nexport function render(index) {\n  render3D(index, index / pixelCount * 2, 0, 0)\n}\n  \n\n\n/*\n  setupRotationMatrix()\n  Takes a vector (ux, uy, uz) which will be the axis to rotate around,\n    and an angle in radians.\n  Computes a 3D rotation matrix and stores it in a global named R\n  \n  https://en.wikipedia.org/wiki/Rotation_matrix\n*/\n\nvar R = array(3); for (i=0; i<3; i++) R[i] = array(3)  // init 3x3, R[r][c]\n\nfunction setupRotationMatrix(ux, uy, uz, angle) {\n  // Rescale ux, uy, uz to make sure it's a unit vector, length = 1\n  length = sqrt(ux * ux + uy * uy + uz * uz)\n  ux /= length; uy /=length; uz /= length\n  \n  // Precompute a few reused values\n  cosa = cos(angle); sina = sin(angle)\n  ccosa = 1 - cosa\n  xyccosa = ux * uy * ccosa\n  xzccosa = ux * uz * ccosa\n  yzccosa = uy * uz * ccosa\n  xsina = ux * sina; ysina = uy * sina; zsina = uz * sina\n  \n  R[0][0] = cosa + ux * ux * ccosa\n  R[0][1] = xyccosa - zsina\n  R[0][2] = xzccosa + ysina\n  R[1][0] = xyccosa + zsina\n  R[1][1] = cosa + uy * uy * ccosa\n  R[1][2] = yzccosa - xsina\n  R[2][0] = xzccosa - ysina\n  R[2][1] = yzccosa + xsina\n  R[2][2] = cosa + uz * uz * ccosa\n}\n\n/*\n  rotate3D()\n  Takes 3 coordinates (x, y, z) and expects R to be a global rotation matrix.\n  Sets globals rx, ry, and rz as the rotated point's new coordinates.\n  (Globals are used for speed and convenience in the Pixelblaze lang)\n*/\nvar rx, ry, rz\nfunction rotate3D(x, y, z) {\n  rx = R[0][0] * x + R[0][1] * y + R[0][2] * z\n  ry = R[1][0] * x + R[1][1] * y + R[1][2] * z\n  rz = R[2][0] * x + R[2][1] * y + R[2][2] * z\n}\n"
  },
  "preview": "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"
}