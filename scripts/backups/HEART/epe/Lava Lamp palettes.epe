{
  "name": "Lava Lamp palettes",
  "id": "3MNrTrqgij6ih5oRD",
  "sources": {
    "main": "// a bunch of fastled gradient palettes\nvar black_Blue_Magenta_White_gp = [\n  0,   0,  0,  0,\n  42,   0,  0, 45,\n  84,   0,  0,255,\n  127,  42,  0,255,\n  170, 255,  0,255,\n  212, 255, 55,255,\n  255, 255,255,255]\n// normalize palette to 0.0 to 1.0 range  \narrayMutate(black_Blue_Magenta_White_gp,(v, i ,a) => v / 255);  \n\nvar es_landscape_33_gp = [\n  0,   1,  5,  0,\n  19,  32, 23,  1,\n  38, 161, 55,  1,\n  63, 229,144,  1,\n  66,  39,142, 74,\n  255,   1,  4,  1]\n// normalize palette to 0.0 to 1.0 range    \narrayMutate(es_landscape_33_gp,(v, i ,a) => v / 255);\n\nvar heatmap_gp = [\n  0,     0,  0,  0,   \n  128,   255,  0,  0,   \n  224,   255,255,  0,   \n  255,   255,255,255 ];\n// normalize palette to 0.0 to 1.0 range   \narrayMutate(heatmap_gp,(v, i ,a) => v / 255);\n\n// list of the palettes we'll be using\nvar palettes = [black_Blue_Magenta_White_gp,es_landscape_33_gp,heatmap_gp]\n\n// control variables for palette switch timing (these are in seconds)\nexport var PALETTE_HOLD_TIME = 5\nexport var PALETTE_TRANSITION_TIME = 2;\n\n// internal variables used by the palette manager.\n// Usually not necessary to change these.\nexport var currentIndex = 0;\nvar nextIndex = (currentIndex + 1) % palettes.length;\n\n// arrays to hold rgb interpolation results\nvar pixel1 = array(3);\nvar pixel2 = array(3);\n\n// array to hold calculated blended palette\nvar PALETTE_SIZE = 16;\nvar currentPalette = array(4 * PALETTE_SIZE)\n\n// timing related variables\nvar inTransition = 0;\nvar blendValue = 0;\nrunTime = 0\n\nexport var scaleFactor = 0.25\n// Startup initialization for palette manager\nsetPalette(currentPalette);\nbuildBlendedPalette(palettes[currentIndex],palettes[nextIndex],blendValue)  \n\n// UI Controls\n\n// transition to the next palette in the sequence\nexport function triggerNextPalette() {\n  runTime = 0;\n  inTransition = 1\n}\n\n// how long we stick with a palette before transitioning to\n// the next one\nexport function sliderHoldTime(v) {\n  PALETTE_HOLD_TIME = 20 * v * v;\n}\n\nexport function sliderScaleFactor(v) {\n  scaleFactor = 1 + (1 - v) * 19 // Subtract v from 1 to reverse the slider.\n}\n\n// time to cross-blend between palettes when switching\nexport function sliderTransitionTime(v) {\n  PALETTE_TRANSITION_TIME = 10 * v * v;\n}\n\n// user space version of Pixelblaze's paint function. Stores\n// interpolated rgb color in rgbArray\nfunction paint2(v, rgbArray, pal) {\n  var k,u,l;\n  var rows = pal.length / 4;\n\n  // find the top bounding palette row\n  for (i = 0; i < rows;i++) {\n    k = pal[i * 4];\n    if (k >= v) break;\n  }\n\n  // fast path for special cases\n  if ((i == 0) || (i >= rows) || (k == v)) {\n    i = 4 * min(rows - 1, i);\n    rgbArray[0] = pal[i+1];\n    rgbArray[1] = pal[i+2];\n    rgbArray[2] = pal[i+3];    \n  }\n  else {\n    i = 4 * (i-1);\n    l = pal[i]   // lower bound    \n    u = pal[i+4]; // upper bound\n\n    pct = 1 -(u - v) / (u-l);\n    \n    rgbArray[0] = mix(pal[i+1],pal[i+5],pct);\n    rgbArray[1] = mix(pal[i+2],pal[i+6],pct);\n    rgbArray[2] = mix(pal[i+3],pal[i+7],pct);    \n  }\n}\n\n// utility function:\n// interpolate colors within and between two palettes\n// and set the LEDs directly with the result.  To be\n// used in render() functions\nfunction paletteMix(pal1, pal2, colorPct,palettePct) {\n  paint2(colorPct,pixel1,pal1);\n  paint2(colorPct,pixel2,pal2);  \n  \n  rgb(mix(pixel1[0],pixel2[0],palettePct),\n      mix(pixel1[1],pixel2[1],palettePct),\n      mix(pixel1[2],pixel2[2],palettePct)\n     )\n}\n\n// construct a new palette in the currentPalette array by blending \n// between pal1 and pal2 in proportion specified by blend\nfunction buildBlendedPalette(pal1, pal2, blend) {\n  var entry = 0;\n  \n  for (var i = 0; i < PALETTE_SIZE;i++) {\n    var v = i / (PALETTE_SIZE - 1);\n    \n    paint2(v,pixel1,pal1);\n    paint2(v,pixel2,pal2);  \n    \n    // build new palette at currrent blend level\n    currentPalette[entry++] = v;\n    currentPalette[entry++] = mix(pixel1[0],pixel2[0],blend)\n    currentPalette[entry++] = mix(pixel1[1],pixel2[1],blend)\n    currentPalette[entry++] = mix(pixel1[2],pixel2[2],blend)    \n  }\n}\n\n\n\n\n\n\n\n// We're using the Perlin FBM function to generate a star field that we can fly through.\n// Lacunarity, gain, and octaves control the character of the Perlin FBM function.\n\nexport var lacunarity = 2 // The lacunarity controls the frequency of the octaves.\nexport var gain = 0.5 // The gain controls the amplitude of the octaves.\nexport var octaves = 4 // The number of noise functions summed together.\n\n// Zoom value, allows to control the density of the star field.\nexport var zoom = 1.0 \n\n// Slider for zoom value, range from 1 to 20.\n// The slider is reversed, i.e., moving the slider to the right (towards 1), decreases zoom,\n// creating an effect of being further from the stars.\nexport function sliderZoom(v) {\n  zoom = 1 + (1 - v) * 19 // Subtract v from 1 to reverse the slider.\n}\n\n// Slider to control lacunarity, between 1.0 and 3.0\nexport function sliderLacunarity(v) {\n  lacunarity = 1 + v * 2\n}\n\n// Slider to control gain, between 0.0 and 1.0\nexport function sliderGain(v) {\n  gain = v\n}\n\n// Slider to control octaves, between 1 and 8\nexport function sliderOctaves(v) {\n  octaves = 1 + floor(v * 7)\n}\n\n// Time variable to create animation.\nvar t = 0 \nexport var theta\nexport function beforeRender(delta) {\n  theta = PI2 * time(0.2);\n  resetTransform()\n  // rotateY(theta)\n  rotateX(theta)\n  scale(scaleFactor,scaleFactor);\n  runTime = (runTime + delta / 1000) % 3600;\n  t += delta / 2000 // Adjust speed of travel.\n  \n  // Palette Manager - handle palette switching and blending with a \n  // tiny state machine  \n  if (inTransition) {\n    if (runTime >= PALETTE_TRANSITION_TIME) {\n      // at the end of a palette transition, switch to the \n      // next set of palettes and reset everything for the\n      // normal hold period.\n      runTime = 0;\n      inTransition = 0\n      blendValue = 0\n      currentIndex = (currentIndex + 1) % palettes.length\n      nextIndex = (nextIndex + 1) % palettes.length   \n\n    }\n    else {\n      // evaluate blend level during transition\n      blendValue = runTime / PALETTE_TRANSITION_TIME\n    }\n    \n    // blended palette is only recalculated during transition times. The rest of \n    // the time, we run with the current palette at full speed.\n    buildBlendedPalette(palettes[currentIndex],palettes[nextIndex],blendValue)          \n  }\n  else if (runTime >= PALETTE_HOLD_TIME) {\n    // when hold period ends, switch to palette transition\n    runTime = 0\n    inTransition = 1\n  }\n}\n// setPerlinWrap(3,256,256);\nexport var n\nsetPerlinWrap(3,256,256);\n\nfunction renderPattern(index, x, y) {\n  // Generate Fractal Brownian Motion with coordinates scaled by zoom factor.\n  var n = perlinFbm(x, y, t, lacunarity, gain, octaves) \n  // var n = perlinRidge(x*zoom, y*zoom, t, lacunarity, gain, 1, octaves)\n  // v = max(smoothstep(flareAmount,1,v),(1-((y*v)-c2)/coreSize));  \n  // The output of the Perlin function is between -1 and 1, so we shift and\n  // scale it to be a brightness value between 0 and 1.\n  n = (wave(n) + 1) / 2.5 \n  // n = smoothstep(0.5,1,n)\n  // Determine hue based on brightness (Perlin noise value).\n  // var hue = n \n  var hue = n - (0.125*n)\n\n  // Set the current pixel to the calculated hue, saturation, and brightness.\n  // hsv(hue, 1, n)\n  paint(hue, 1);\n}\n\n\n// Add your pattern render() code here -- just use paint to get color\n// from the current blended palette.\nexport function render(index) {\n  pct = index / pixelCount  // Transform index..pixelCount to 0..1\n  render2D(index, 3 * pct, 0)   // Render 3 top rows worth to make it denser\n}\n\nexport function render2D(index, x, y) {\n  renderPattern(index, x, y)\n}\n\n// You can also project up a dimension. Think of this as mixing in the z value\n// to x and y in order to compose a stack of matrices.\nexport function render3D(index, x, y, z) {\n  x1 = (x - cos(z / 4 * PI2)) / 2\n  y1 = (y - sin(z / 4 * PI2)) / 2\n  render2D(index, x1, y1)\n}"
  },
  "preview": "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"
}