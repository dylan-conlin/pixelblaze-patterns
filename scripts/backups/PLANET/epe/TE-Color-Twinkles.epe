{
  "name": "TE-Color-Twinkles",
  "id": "w7QSZREpGa2Mpa52q",
  "sources": {
    "main": "// Titanic's End-colored variation on the stock \"color twinkles\"\n// pattern\n\nvar TE_Cyan_Blue_Purple = [\n  0.0, 0.1326, 0.0038, 0.16,        // plumice dark purple\n  0.1666, 0.1059, .0055, 0.4818,    // sunset purple  \n  0.3333, 0.061, 0.0246, 0.5610,    // synwavedyn purpler\n  0.5, 0.4086, 0.25196, 0.9006,     // IceGrad desat light purple  \n  0.6667, 0.1964, 0.6029, 1.0,      // sunwave cyan  \n  1.0, 0.1246, 0.6275, 0.8277,      // iecOlate cyan\n  ]\n\nvar TE_Pink_Purple = [\n    0.0, 0.1059, 0.0055, 0.4818,    \n    0.3333, 0.1059, 0.02977, 0.5610, \n    0.6667, 0.3986, 0.0246, 0.2034, \n    1.0, 0.9006, 0.2105, 0.4603,\n]\n\nvar TE_Cyan_Green = [\n    0.0, 0.0038, 0.3888, 0.2214,    \n    0.3333, 0.0055, 0.7924, 0.346,\n    0.6667, 0.1273, 0.9006, 0.7924, \n    1.0, 0.1569, 0.609, 0.8277, \n]\n\nvar TE_Orange_Green = [\n    0.0, 0.1301, 0.9231, 0.0015,    \n    0.5, 0.5206, 0.9156, 0.0339, \n    1.0, 0.9231, 0.5206, 0.0629,\n]\n\nvar TE_Cyan_Ice = [\n    0.0, 0.0024, 0.1164, 0.9006,    \n    0.1667, 0.0465, 0.2599, 0.9006, \n    0.3333, 0.0517, 0.4982, 0.8277, \n    0.5, 0.1963, 0.6029, 1.0,       \n    0.6667, 0.1246, 0.6275, 0.8277,  \n    1.0, 0.6275, 0.7108, 1.0,      \n]\n\nvar pal = TE_Cyan_Blue_Purple;\n\nvar palettes = [TE_Cyan_Blue_Purple,TE_Pink_Purple,TE_Cyan_Green,TE_Orange_Green,TE_Cyan_Ice]\n// control variables for palette switch timing (these are in seconds)\nexport var PALETTE_HOLD_TIME = 2\nexport var PALETTE_TRANSITION_TIME = 2;\nvar PALETTE_HOLD = 0;\n\n// internal variables used by the palette manager.\n// Usually not necessary to change these.\nexport var currentIndex = 0;\nvar nextIndex = (currentIndex + 1) % palettes.length;\n\n// arrays to hold rgb interpolation results\nvar pixel1 = array(3);\nvar pixel2 = array(3);\n\n// array to hold calculated blended palette\nvar PALETTE_SIZE = 16;\nvar currentPalette = array(4 * PALETTE_SIZE)\n\n// timing related variables\nvar inTransition = 0;\nvar blendValue = 0;\nrunTime = 0\nspeed = 0.333;\nexport var density = 0.1;\n\n// Startup initialization for palette manager\nsetPalette(currentPalette);\nbuildBlendedPalette(palettes[currentIndex],palettes[nextIndex],blendValue)  \n\n// UI Controls\nexport function sliderSpeed(v) {\n  speed = v;\n}\n\nexport function sliderDensity(v) {\n  density = 1-max(v,0.002);\n}\n\n// how long we stick with a palette before transitioning to\n// the next one\nexport function sliderHoldTime(v) {\n  PALETTE_HOLD_TIME = 20 * v * v;\n}\n\n// time to cross-blend between palettes when switching\nexport function sliderTransitionTime(v) {\n  PALETTE_TRANSITION_TIME = 10 * v * v;\n}\n\nexport function togglePaletteHold(v) {\n  PALETTE_HOLD = v;\n}\n\n// user space version of Pixelblaze's paint function. Stores\n// interpolated rgb color in rgbArray\nfunction paint2(v, rgbArray, pal) {\n  var k,u,l;\n  var rows = pal.length / 4;\n\n  // find the top bounding palette row\n  for (i = 0; i < rows;i++) {\n    k = pal[i * 4];\n    if (k >= v) break;\n  }\n\n  // fast path for special cases\n  if ((i == 0) || (i >= rows) || (k == v)) {\n    i = 4 * min(rows - 1, i);\n    rgbArray[0] = pal[i+1];\n    rgbArray[1] = pal[i+2];\n    rgbArray[2] = pal[i+3];    \n  }\n  else {\n    i = 4 * (i-1);\n    l = pal[i]   // lower bound    \n    u = pal[i+4]; // upper bound\n\n    pct = 1 -(u - v) / (u-l);\n    \n    rgbArray[0] = mix(pal[i+1],pal[i+5],pct);\n    rgbArray[1] = mix(pal[i+2],pal[i+6],pct);\n    rgbArray[2] = mix(pal[i+3],pal[i+7],pct);    \n  }\n}\n\n// utility function:\n// interpolate colors within and between two palettes\n// and set the LEDs directly with the result.  To be\n// used in render() functions\nfunction paletteMix(pal1, pal2, colorPct,palettePct) {\n  paint2(colorPct,pixel1,pal1);\n  paint2(colorPct,pixel2,pal2);  \n  \n  rgb(mix(pixel1[0],pixel2[0],palettePct),\n      mix(pixel1[1],pixel2[1],palettePct),\n      mix(pixel1[2],pixel2[2],palettePct)\n   )\n}\n\n// construct a new palette in the currentPalette array by blending \n// between pal1 and pal2 in proportion specified by blend\nfunction buildBlendedPalette(pal1, pal2, blend) {\n  var entry = 0;\n  \n  for (var i = 0; i < PALETTE_SIZE;i++) {\n    var v = i / (PALETTE_SIZE - 1);\n    \n    paint2(v,pixel1,pal1);\n    paint2(v,pixel2,pal2);  \n    \n    // build new palette at currrent blend level\n    currentPalette[entry++] = v;\n    currentPalette[entry++] = mix(pixel1[0],pixel2[0],blend)\n    currentPalette[entry++] = mix(pixel1[1],pixel2[1],blend)\n    currentPalette[entry++] = mix(pixel1[2],pixel2[2],blend)    \n  }\n}\n  \nexport function beforeRender(delta) {\n  runTime = (runTime + delta / 1000) % 3600;\n\n  // Palette Manager - handle palette switching and blending with a \n  // tiny state machine  \n  if (inTransition) {\n    if (runTime >= PALETTE_TRANSITION_TIME) {\n      // at the end of a palette transition, switch to the \n      // next set of palettes and reset everything for the\n      // normal hold period.\n      runTime = 0;\n      inTransition = 0\n      blendValue = 0\n      currentIndex = (currentIndex + 1) % palettes.length\n      nextIndex = (nextIndex + 1) % palettes.length   \n\n    }\n    else {\n      // evaluate blend level during transition\n      blendValue = runTime / PALETTE_TRANSITION_TIME\n    }\n    \n    // blended palette is only recalculated during transition times. The rest of \n    // the time, we run with the current palette at full speed.\n    buildBlendedPalette(palettes[currentIndex],palettes[nextIndex],blendValue)          \n  }\n  else if (runTime >= PALETTE_HOLD_TIME) {\n    // when hold period ends, switch to palette transition\n    if (!PALETTE_HOLD) {\n      runTime = 0\n      inTransition = 1\n    }\n  }\n  \n  // pattern-specific code below this line\n  timebase = (timebase + (delta * speed / 1000)) % 3600;  \n  t1 = timebase / 3.333;\n}\n\nexport function render(index) {\n  h = sin(index / 3 + PI2 * sin(index / 2 + t1))\n  v = wave(index / 3 / PI2 + sin(index / 2 + timebase))\n  v = v > density ? v * v * v * v : 0\n  paint(h,v)\n}"
  },
  "preview": "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"
}