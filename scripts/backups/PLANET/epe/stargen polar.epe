{
  "name": "stargen polar",
  "id": "MgzRtoBxLqtuEjMTC",
  "sources": {
    "main": "/*\n  StarGen: A generic star generator for polar-mapped 2D displays.\n  \n  Demo video: https://youtu.be/ehWF5ZE1VVA\n  $30 241 LED circular display: https://www.amazon.com/gp/product/B083VWVP3J\n  Map: https://gist.github.com/jvyduna/7a14e7449c63363e01ebbf26fcfba685\n    (hat tip to Scruffynerf for the cartesian)\n  \n  Polar maps are assumed to be stored as 0..1 in each of [r, phi, theta]\n  \n  I've used the physics convention as shown in:\n    https://en.wikipedia.org/wiki/Spherical_coordinate_system\n  \n    r: distance from origin\n    phi: rotation about z axis\n    theta: azimuth angle from the +z axis\n\n  Remember that in Pixelblaze, the final extents for each dimension are scaled to\n  0..1, so a phi of 0.5 is like PI in radians; theta of 0.5 is on the XY plane.\n  \n  Crossfades with \"shimmer\" effect between modes.\n  \n  Jeff Vyduna, 2020 / MIT License\n*/\n\nvar modeOverride = 0       // If >0, manually force disply of a selected mode\nexport function sliderModeOverride(v) {\n  modeOverride = floor(v * modeCount)\n  mode = modeOverride - 1\n}\n\nvar secPerMode = 20        // Default for the seconds spent in each mode\nxFadePct = 4 / secPerMode  // Percentage of the time spent in crossfades\nexport function sliderMinutesPerMode(v) {\n  secPerMode = v * 60\n  xFadePct = 4 / secPerMode\n}\n\nexport var offsetAngle = 0 // Tune for your physical install's rotation\nexport function sliderOffsetAngle(v) { offsetAngle = v }\n\n// export var p1 // Parameter sometimes used for testing/tuning\n// export function sliderParam1(v) { p1 = v }\n\nvar modeCount = 12         // Total number of modes we're cycling through\nvar beforeRenders = array(modeCount)\n// init all beforeRenderers to empty anonymous functions\nfor (i = 0; i < modeCount; i++) beforeRenders[i] = function(d) {}\n// These are the animation modes it will cycle through\nrenderers = array(modeCount)\n\nbeforeRenders[0] = beforeOvals\nrenderers[0] = ovals\nbeforeRenders[1] = beforeSinustar6\nrenderers[1] = sinustar6\nbeforeRenders[2] = beforeSinushimmer\nrenderers[2] = sinushimmer\nbeforeRenders[3] = beforeDavid\nrenderers[3] = david\nbeforeRenders[4] = beforeBethlehem\nrenderers[4] = bethlehem\nbeforeRenders[5] = beforePentagram\nrenderers[5] = pentagram\nbeforeRenders[6] = beforeDecagram\nrenderers[6] = decagram\nbeforeRenders[7] = beforeHexagram\nrenderers[7] = hexagram\nrenderers[8] = heart\nbeforeRenders[9] = beforeBirdflap\nrenderers[9] = birdflap\nbeforeRenders[10] = beforeRainbowSpirals\nrenderers[10] = rainbowSpirals\nbeforeRenders[11] = beforeSnowglobe\nrenderers[11] = snowglobe\n\nexport var mode, modeTime\nexport function beforeRender(delta) {\n  tMode = time(secPerMode * modeCount / 65.536) // 0..1 through entire playlist\n  if (modeOverride == 0) mode = floor(modeCount * tMode)\n  \n  // Compute this beforeRenderer and sometimes, the next\n  beforeRenders[mode](delta)\n  \n  // Decimal progress through all modes, 0..modeCount\n  modeTime = time(secPerMode * modeCount / 65.536) * modeCount\n \n  // 0 when not crossfading; 0..0.999 when crossfading\n  pctIntoXfFade = max(((modeTime % 1) - (1 - xFadePct)) / xFadePct, 0)\n  // We'll need the next mode's beforeRender if crossfading into it\n  if (pctIntoXfFade > 0) beforeRenders[(mode + 1) % modeCount](delta)\n}\n\n\nexport function render3D(index, r, phi, theta) {\n  /* \n    If we're crossfading mode 1 to mode 2, we randomly pick that this pixel will\n    come from either mode 1's renderer or mode 2's. Which one it comes from \n    is probabilistically related to the percentage we're into this crossfade.\n  */\n  skew = random(1) < wave((pctIntoXfFade - 0.5) / 2) // wave makes it \"tween\"\n\n  // modeOverride == 0 means run the playlist\n  if (modeOverride == 0) mode = floor((modeTime + skew) % modeCount)\n  \n  // Note that using `- offsetAngle` instead is viable but watch for sign issues, \n  // like assumptions around abs(phi) or phi^3.\n  renderers[mode](index, r, phi + offsetAngle, theta)\n}\n  \nexport function render2D(index, r, phi) {\n  render3D(index, r, phi, .5) // Equatorial section\n}\n\nexport function render(index) {\n  render2D(index, index / pixelCount, 0)\n}\n\n\n\n// Renderers\n\n// Somewhat of a celestial orbit path / star\nvar ovalHue, o3, o4_6_10, o8, o15, t6\nfunction beforeOvals(delta) {\n  o8 = osc(8)\n  ovalHue = 0.07 + ((o8 > .96) ? 1 - o8 : 0)\n  o3 = osc(3); o15 = osc(15)\n  o4_6_10 = osc(4) * osc(6) * osc(10)\n  t6 = time(6 / 65.536)\n}\nfunction ovals(index, r, phi, theta) {\n  var p = (phi - t6 * o15) * PI2\n  p += r * o4_6_10  // Adds occasional galaxy skew\n  var a = 1 + 2 * o3\n  var b = 1 + 2 * o8 + 2 - a\n  \n  line = near(4 * r,\n    a * b / sqrt(pow(b * cos(p), 2) + pow(a * sin(p), 2))\n  , 1)\n  hsv(ovalHue, .85 - .08 * (1 - abs(a - b)), line)\n  \n  if (r == 0) hsv(o8, 1, .5) // Colorful center pixel\n}\n\n\n// At times, it's snowflake-esque\nvar t3\nfunction beforeSinustar6(delta) {\n  t3 = time(3 / 65.536)\n}\nfunction sinustar6(index, r, phi, theta) {\n  line = near(r,\n    2 * osc(10) + .4 * cos((6 * phi - t3) * PI2)\n  , .4)\n  hsv(0, 0, line)\n}\n\n// Note sure what's going on here. Snow? Digital Bob Ross\n// is pleased with this happy little accident.\nvar t3\nfunction beforeSinushimmer(delta) {\n  t3 = time(3 / 65.536)\n}\nfunction sinushimmer(index, r, phi, theta) {\n  line = near(r, \n    0.94 + .4 * cos((6 * phi * 6 - t3) * PI2)\n  , .4)\n  hsv(0, 0, line)\n}\n\n\n// Kaleidoscopic abstract star of David, sometimes, for a moment\nvar o21, o23, dSides\nfunction beforeDavid(delta) {\n  o21 = osc(21)\n  o23 = osc(23) \n  dSides = 6\n}\nfunction david(index, r, phi, theta) {\n  slice = floor(phi * dSides * 2)\n  parity = slice % 2\n  line = near(r, \n    o23 / cos(PI2 * (phi + o21 - parity / dSides - slice / dSides / 2))\n  )\n  hsv(0, 0, line)\n}\n\n\n// Star over Bethlehem\nvar o40, o50\nfunction beforeBethlehem(delta) {\n  o4 = osc(4)\n  o5 = osc(5)\n}\nfunction bethlehem(index, r, phi, theta) {\n  line = wrappedNear(phi * 8 % 1, 1, 1.1 - pow(r, 2 * o5))\n  // Oranger near the outside\n  var h = 0.05 + (1 - r) / 8\n  var s = sqrt(sqrt(r))\n  // Makes the 45deg rays fade in and out\n  var v = line - o4 * triangle(4 * (phi - PI2 / 8))\n  hsv(h, s, v)\n}\n\n\n// Pentagram: https://www.desmos.com/calculator/uessc1gnli\nvar o50, wander\nfunction beforePentagram(delta) {\n  o50 = osc(50)\n  var lfo = 80 * triangle(time(600 / 65.536)) - 20\n  // Scale: https://www.desmos.com/calculator/qgt5bvbv0d\n  pentaParam1 = pow(1.6 * sin(lfo) / lfo + 1.532, 3) - 1\n  \n  // Random bounded wandering value\n  wander = clamp(wander + 0.001 * (random(2) - 1), -.4, .4)\n  // Used for thickness of the \"line\" that's plotted\n  pentaParam2 = 3.6 / 30 * pentaParam1 + .4 + wander\n}\nfunction pentagram(index, r, phi, theta) {\n  line = near(r * pentaParam1, \n    //          sides        sides      rotation  \n    1 / cos(2 / 5 * acos(cos(5 * (phi - o50) * PI2)))\n  , pentaParam2)\n  hsv(0, 0, line)\n}\n\n\nvar o400\nfunction beforeDecagram(delta) {\n  o400 = osc(400) // Very slow rotation\n}\nfunction decagram(index, r, phi, theta) {\n  line = near(r * 3.5,\n    //      2/sides       sides*2     rotation\n    1 / cos(.4 * acos(cos(10 * (phi - o400) * PI2)))\n  , 1.5)\n  hsv(0, 0, line + (r < .3)) // Filled center\n}\n\n\nvar o40\nfunction beforeHexagram(delta) {\n  o40 = osc(40)\n}\nfunction hexagram(index, r, phi, theta) {\n  var sides = 6\n  line = near(r * 2.5,\n    1 / cos(2 / sides * acos(cos(sides * (phi - o40) * PI2)))\n  , .45)\n  hsv(0, 0, line)\n}\n\n\nfunction heart(index, r, phi, theta) {\n  var s = osc(20)\n  var p = (phi - .5) * PI2\n  line = near(4 * s * r,\n    2 - 2 * sin(p) + sin(p) * sqrt(abs(cos(p))) / (sin(p) + 1.4)\n  , .6)\n  hsv(0, 1.5 * sqrt(s), line)\n}\n\n\n// A birdlike thing\nvar wingbend, breath, flap\nfunction beforeBirdflap(delta) {\n  wingbend = .175 + osc(2.5) * .35\n  breath = .2 + .9 * osc(4)\n  flap = -.19 +           // Wings' dihedral angle\n          .14 * abs(cos(PI2 * time(5 / 65.536))) // Wingsroke animation\n}\nfunction birdflap(index, r, phi, theta) {\n  line = near(r, \n    // bend               createsV  rotation\n    wingbend / cos(PI2 * (abs(phi - 1.253 ) + flap) )\n  , .9 * r)\n  hsv(0.04, 0.95, breath * line)\n}\n\n\nvar lfo10, lfo8, lfo6\nfunction beforeRainbowSpirals(delta) {\n  slowness = 9\n  lfo10 = 3 * osc(5 * slowness)\n  lfo8 = .5 + osc(4 * slowness)\n  lfo6 = .1 + osc(3 * slowness)\n}\nfunction rainbowSpirals(index, r, phi, theta) {\n  var line = 0\n  line = near(2 * (r * lfo10 % lfo8), lfo6 * phi)\n\n  hsv(fixH(r + phi), 1, line)\n}\n\n\n// Snowglobe is a deriviative of the default Sparks pattern\nvar numSparks = 20\nvar friction = 1 / pixelCount / 2\nvar sparks = array(numSparks)\nvar sparkX = array(numSparks)\nvar pixels = array(pixelCount)\n\nfunction beforeSnowglobe(delta) {\n  delta *= .1\n  for (i = 0; i < pixelCount; i++) pixels[i] = 0\n  for (i = 0; i < numSparks; i++) {\n    if (abs(sparks[i]) <= .001) {\n      sparks[i] = .1 + random(.4)\n      sparkX[i] = random(pixelCount)\n      if (random(1) > .5) sparks[i] *= -1\n    }\n    sparks[i] -= friction * delta * (sparks[i] > 0 ? 1 : -1)\n    sparkX[i] += sparks[i] * delta\n    if (sparkX[i] > pixelCount || sparkX[i] < 0) {\n      sparkX[i] = 0; sparks[i] = 0\n    }\n    pixels[sparkX[i]] += abs(sparks[i])\n  }\n}\nfunction snowglobe(index) {\n  var v = pixels[index]\n  hsv(.63, 1 - v, v * v)\n}\n\n\n// Utilities\n\n// Helper to quickly define 0-1 oscillators of a defined period. Becomes\n// ineffecient unless only used in beforeRenders.\nfunction osc(sec) { return wave(time(sec / 65.536)) }\n\n// Several modes define a line in space. This sets the defualt thickness of\n// those. Use a higher percentage for projects with fewer pixels.\nvar halfwidthDefault = 0.125\n\n// Returns 1 when a & b are proximate, 0 when they are more than `halfwidth`\n// apart, and a gamma-corrected brightness for distances within `halfwidth`\nfunction near(a, b, halfwidth) {\n  if (halfwidth == 0) halfwidth = halfwidthDefault\n  var v = clamp(1 - abs(a - b) / halfwidth, 0, 1)\n  return v * v\n}\n\n/*\n  Assuming a & b are given as angles, where a=0 corresponds to 0 radians,\n  a=0.25 corresponds to Pi/2 radians, and a=1 wraps back to 0 radians...\n  Returns 1 when a & b are proximate as angles on a circle, 0 when they\n  are more than `width/2` apart, and a gamma-corrected brightness for\n  distances within `width/2`\n*/\nfunction wrappedNear(a, b, halfwidth) {\n  if (halfwidth == 0) halfwidth = halfwidthDefault\n  var v = clamp(1 - triangle(a - b) / halfwidth / 2, 0, 1)\n  return v * v\n}\n\n// Perceptual hue conversion - Improves HSV to  a more human perception \n// of a balanced rainbow\nfunction fixH(pH) {\n  pH = pH % 1 + (pH < 1)  // Wrap inputs\n  return wave((pH-0.5)/2)\n}\n"
  },
  "preview": "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"
}