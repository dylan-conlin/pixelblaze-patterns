{
  "name": "Fractal Flower",
  "id": "5dgTQh4Zy3wY9w7Hh",
  "sources": {
    "main": "/*\nFractal Flower\n2021 Ben Hencke\n*/\n\n//*********** Settings ***********/\n//set up the source matrix dimensions - match to your display for best results\n//or set lower for a pixelated mosaic\nvar width = 20\nvar height = 20\n\n//globals for dynamic settings\n//*********** Settings ***********/\n\nexport var iterations = 5\nexport var drawLevels = 4 //skip drawing some starting iterations\n\nexport var scale = .035\nexport var speed = 7\nexport var fade = .9\n\nexport var angleRange1 = 1\nexport var angleRange2 = 1\n\nexport var replicas = 5\nexport var spacing = .2\n\nexport var useWhite = true\nexport var usePinwheel = true\nexport var wrapWorld = false\n\n\n//globals for calculations\n//*********** Settings ***********/\nvar pixels = array(width * height)\nvar hues = array(width * height)\nvar color, branchAngle1, branchAngle2, h, v\n\n//*********** Globals for watching ***********/\nexport var iter //see how many iterations are run\nexport var maxValue //the brightest pixel\nexport var valueFactor = 20 //used to adjust brightness automatically\n\n//*********** UI Controls ***********/\nexport function sliderIterations(v) {iterations = 1 + floor(v*8)}\nexport function sliderDrawLevels(v) {drawLevels = 1 + floor(v*8)}\nexport function sliderScale(v) {scale = v * v * .1}\nexport function sliderSpeed(v) {speed = 1 + ceil(v * 10) * 3}\nexport function sliderAngleRange1(v) {angleRange1 = v * 2}\nexport function sliderAngleRange2(v) {angleRange2 = v * 2}\nexport function sliderTrails(v) {fade = v && (v * .5 + .5)}\nexport function sliderReplicas(v) {replicas = 1 + floor(v*12)}\nexport function sliderSpacing(v) {spacing = v/2}\nexport function sliderWhiteMode(v) {useWhite = v > .5}\nexport function sliderPinwheelMode(v) {usePinwheel = v > .5}\nexport function sliderWrapMode(v) {wrapWorld = v > .5}\n\n//*********** Utility Functions ***********/\n//map an x and y into a 1D array\nfunction getIndex(x, y) {\n  var res = floor(x*width) + floor(y*height)*width\n  return res\n}\n\nfunction blendHue(h1, v1, h2, v2) {\n  v = v1+v2\n  //rotate hues so that they are closer numerically\n  if (h2 - h1 > .5)\n    h2 -= 1\n  if (h1 - h2 > .5)\n    h1 -= 1\n  //average the hues, weighted by brightness\n  h = (h1 * v1 + h2 * v2) / v\n}\n\n//*********** Fractal Implementation ***********/\nfunction fractal(x, y, a, i) {\n  var index, l\n  iter++ //keep track of how many calls we've made\n\n  //move coordinates in direction vector for our angle\n  //each iteration travels a smaller distance\n  //but don't travel for the first iteration\n  if (i < iterations)  {\n    l = i * scale + scale\n    x += sin(a) * l;\n    y += cos(a) * l;\n  }\n\n    //make coordinates \"wrap\" around to the other side\n    if (wrapWorld) {\n      x = mod(x,.99999)\n      y = mod(y,.99999)\n    }\n\n    //skip earlier levels, and only draw \"on screen\"\n    if(i <= drawLevels && x >= 0 && x <= .99999 && y >= 0 && y <= .999999) {\n    index = getIndex(x,y)\n\n    // blendHue(hues[index], pixels[index], iter * .004 + color , hues[index] + 1)\n    blendHue(hues[index], pixels[index], i * .1 + color, 1)\n\n    hues[index] = h\n    pixels[index] = v\n    }\n\n    if (--i > 0) {\n    //if there are more iterations left, recurse to this function adding rotations for each branch\n    fractal(x, y, a + branchAngle1, i)\n    fractal(x, y, a + branchAngle2, i)\n    }\n    }\n\n    //*********** Rendering ***********/\n\n    export function beforeRender(delta) {\n    var startingAngle, i\n\n    //update globals used by the fractal\n    color = time(1 / speed)\n    branchAngle1 = -1 + sin(wave(time(4.4 / speed))*PI2) * PI * angleRange1\n    branchAngle2 = .5 + sin(wave(-time(11 / speed))*PI2) * PI * angleRange2\n\n    startingAngle = sin(time(3 / speed) * PI2) * PI\n\n    iter = 0\n    if (replicas > 1) {\n    for (i = 0; i < replicas; i++) {\n    if (usePinwheel) {\n    //pinwheel - rotate petal in place\n    fractal(0.5 + spacing * sin(i/replicas * PI2), 0.5 + spacing * cos(i/replicas * PI2), startingAngle + i/replicas * PI2, iterations)\n    } else {\n    //roate petals around center\n    fractal(0.5 + spacing * sin(i/replicas * PI2 + startingAngle), 0.5 + spacing * cos(i/replicas * PI2 + startingAngle), 0*startingAngle + i/replicas * PI2, iterations)\n    }\n    }\n    } else {\n    //for a single fractal instance, ignore spacing and draw in center.\n    fractal(.5,.5, startingAngle, iterations)\n    }\n\n    //adjust valueFactor to scale brightness based on the last maxValue found in the previous render\n    //this helps bring out more detail when many fractal dots overlap\n    //do this gradially over time to avoid flickering\n    valueFactor = clamp(valueFactor*.95 + maxValue*.05, 1, 100)\n    maxValue = 0\n    }\n\n    export function render2D(index, x, y) {\n    index = getIndex(x, y) //figure out index from coordinate\n    v = pixels[index]\n    //fade out pixel values\n    pixels[index] = v * fade\n\n    maxValue = max(maxValue, v) //keep track of the brightest pixel\n    v = v / valueFactor //scale brightness down\n    v = v*v //give things a bit more contrast\n    if (useWhite)\n    s = 1 - v //highlight bright pixels by shifting toward white\n    else\n    s = 1\n    hsv(hues[index], s, v)\n}\n"
  },
  "preview": "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"
}