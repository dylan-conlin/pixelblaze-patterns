{
  "name": "Shimmer Crossfade",
  "id": "ZHAqrPmXHkCos38n9",
  "sources": {
    "main": "/*\n  Demo on 8x8 matrix: https://youtu.be/r0iVGnwqEEE\n  \n  This pattern shows how to combine several 2D patterns into one with a simple \n  crossfade based on probabilistically picking to render a pixel using the next\n  pattern. The effect looks like a shimmering transition. This approach was \n  inspired by the crossfade used in:\n  \n  https://hackaday.com/2020/04/21/a-jaw-dropping-demo-in-only-256-bytes/\n  \n  The big benefit is that it doesn't require much rewriting of patterns and \n  doesn't need to compute HSV blending like a real crossfader would.\n  \n  To combine patterns, first copy them together into one and de-conflict \n  any global variable names, like `v` or `t1`. Then rename each beforeRender() \n  and render2D() into anonymous functions in their respective arrays.\n  \n  For example, for the first pattern: \n    export function beforeRender(delta) {}\n  becomes:\n    beforeRenders[0] = function (delta) {}\n  and\n    export function render2D(index, x, y) {}\n  becomes\n    renderers[0] = (index, x, y) => {}\n\n*/\n\nsecondsPerMode = 5\nxFadePct = 0.3 // Percentage of the time we spend in crossfades\n\nmodeCount = 3\nbeforeRenders = array(modeCount)\nrenderers = array(modeCount)\n\nexport function beforeRender(delta) {\n  modeTime = time(secondsPerMode * modeCount/ 65.536) * modeCount\n  \n  // 0 when not crossfading; 0..0.999 when crossfading\n  pctIntoXfFade = max(((modeTime % 1) - (1 - xFadePct)) / xFadePct, 0)\n  \n  for (var m = 0; m < modeCount; m++) {\n    beforeRenders[m](delta) // computes ALL beforeRenders\n  }\n  // ToDo: For many patterns combined, enhance that to just call the 2 needed\n}\n\nexport function render2D(i, x, y) {\n  /* \n    If we're crossfading mode 1 to mode 2, we randomly pick that this pixel will\n    come from either mode 1's renderer or mode 2's. Which one it comes from \n    is probabilistically related to the percentage we're into this crossfade.\n  */\n  skew = random(1) < wave((pctIntoXfFade - 0.5) / 2) // wave makes it \"tween\"\n\n  thisPixelMode = floor((modeTime + skew) % modeCount)\n  renderers[thisPixelMode](i, x, y)\n}\n\n\n\n// Here's the code copied in from other patterns\n\n// Rotating white line\nbeforeRenders[0] = (delta) => {\n  angle = time(secondsPerMode / 65.536) * PI2\n  m = tan(angle) // Slope\n  m = clamp(m, -180, 180) // Prevent m * m overflow later\n}\n\nrenderers[0] = (index, x, y) => {\n  distance = abs(-m * x + y + (m - 1) / 2) / sqrt(m * m + 1)\n  v = clamp((0.2 - distance)/0.2, 0, 1)\n  hsv(0, 0, v * v)\n}\n\n// 'Matrix 2D Pulse' - rainbow circles\nbeforeRenders[1] = (delta) => {\n  t1 = time(3.3 / 65.536) * PI2\n  t2 = time(6.0 / 65.536) * PI2\n  z = 1 + wave(time(13 / 65.536)) * 5\n}\n\nrenderers[1] = (index, x, y) => {\n  v = h = (1 + sin(x * z + t1) + cos(y * z + t2)) * 0.5\n  v = v * v * v / 2 \n  hsv(h, 1, v)\n}\n\n// Rotating checkerboard\nbeforeRenders[2] = function (delta) {}\nrenderers[2] = function (index, x, y) {\n  phi = PI2 * time(8 / 65.536)   // Rotation angle in radians. Try 8 seconds.\n  x0 = 0.5; y0 = 0.5             // Center of rotation\n  x = x - x0;  y = y - y0        // Shift the center to the origin\n  _x = x * cos(phi) - y * sin(phi) + 3 * x0 // Rotate around origin and re-shift\n  _y = y * cos(phi) + x * sin(phi) + 2 * y0\n  t20 = time(3 / 65.536)         // Zoom scale and color. Try 3 seconds.\n  blocks = 0.5 + 2 * wave(t20)   // Number of blocks visible\n  \n  h = (_x + _y - t20 - 1)/20\n  v = (1 + floor(1 + _x * blocks) + floor(1 + _y * blocks)) % 2 < 1\n  hsv(h, 1, v)\n}\n\n// You can also project up a dimension. Think of this as mixing in the z value\n// to x and y in order to compose a stack of matrices.\nexport function render3D(index, x, y, z) {\n  x1 = (x - cos(z / 4 * PI2)) / 2\n  y1 = (y - sin(z / 4 * PI2)) / 2\n  render2D(index, x1, y1)\n}\n\n\n\n"
  },
  "preview": "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"
}